"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.groupOfLockupScript = exports.subContractId = exports.contractIdFromTx = exports.addressFromTokenId = exports.addressFromContractId = exports.addressFromScript = exports.addressFromPublicKey = exports.publicKeyFromPrivateKey = exports.groupOfPrivateKey = exports.tokenIdFromAddress = exports.contractIdFromAddress = exports.groupOfAddress = exports.isContractAddress = exports.isAssetAddress = exports.isValidAddress = exports.validateAddress = exports.AddressType = void 0;
const elliptic_1 = require("elliptic");
const bn_js_1 = __importDefault(require("bn.js"));
const constants_1 = require("../constants");
const blakejs_1 = __importDefault(require("blakejs"));
const bs58_1 = __importStar(require("../utils/bs58"));
const utils_1 = require("../utils");
const lockup_script_codec_1 = require("../codec/lockup-script-codec");
const codec_1 = require("../codec");
const djb2_1 = __importDefault(require("../utils/djb2"));
const error_1 = require("../error");
const ec = new elliptic_1.ec('secp256k1');
const PublicKeyHashSize = 32;
var AddressType;
(function (AddressType) {
    AddressType[AddressType["P2PKH"] = 0] = "P2PKH";
    AddressType[AddressType["P2MPKH"] = 1] = "P2MPKH";
    AddressType[AddressType["P2SH"] = 2] = "P2SH";
    AddressType[AddressType["P2C"] = 3] = "P2C";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
function validateAddress(address) {
    decodeAndValidateAddress(address);
}
exports.validateAddress = validateAddress;
function isValidAddress(address) {
    try {
        validateAddress(address);
        return true;
    }
    catch {
        return false;
    }
}
exports.isValidAddress = isValidAddress;
function decodeAndValidateAddress(address) {
    const decoded = (0, bs58_1.base58ToBytes)(address);
    if (decoded.length === 0)
        throw new Error('Address is empty');
    const addressType = decoded[0];
    if (addressType === AddressType.P2MPKH) {
        let multisig;
        try {
            multisig = lockup_script_codec_1.lockupScriptCodec.decode(decoded).value;
        }
        catch (error) {
            throw new error_1.TraceableError(`Invalid multisig address: ${address}`, error);
        }
        const n = multisig.publicKeyHashes.length;
        const m = multisig.m;
        if (n < m || m <= 0) {
            throw new Error(`Invalid multisig address, n: ${n}, m: ${m}`);
        }
        const encodedNSize = codec_1.i32Codec.encode(n).length;
        const encodedMSize = codec_1.i32Codec.encode(m).length;
        const size = encodedNSize + PublicKeyHashSize * n + encodedMSize + 1; // 1 for the P2MPKH prefix
        if (decoded.length === size)
            return decoded;
    }
    else if (addressType === AddressType.P2PKH || addressType === AddressType.P2SH || addressType === AddressType.P2C) {
        // [type, ...hash]
        if (decoded.length === 33)
            return decoded;
    }
    throw new Error(`Invalid address: ${address}`);
}
function isAssetAddress(address) {
    const addressType = decodeAndValidateAddress(address)[0];
    return addressType === AddressType.P2PKH || addressType === AddressType.P2MPKH || addressType === AddressType.P2SH;
}
exports.isAssetAddress = isAssetAddress;
function isContractAddress(address) {
    const addressType = decodeAndValidateAddress(address)[0];
    return addressType === AddressType.P2C;
}
exports.isContractAddress = isContractAddress;
function groupOfAddress(address) {
    const decoded = decodeAndValidateAddress(address);
    const addressType = decoded[0];
    const addressBody = decoded.slice(1);
    if (addressType == AddressType.P2PKH) {
        return groupOfP2pkhAddress(addressBody);
    }
    else if (addressType == AddressType.P2MPKH) {
        return groupOfP2mpkhAddress(addressBody);
    }
    else if (addressType == AddressType.P2SH) {
        return groupOfP2shAddress(addressBody);
    }
    else {
        // Contract Address
        const id = contractIdFromAddress(address);
        return id[`${id.length - 1}`];
    }
}
exports.groupOfAddress = groupOfAddress;
// Pay to public key hash address
function groupOfP2pkhAddress(address) {
    return groupFromBytesForAssetAddress(address);
}
// Pay to multiple public key hash address
function groupOfP2mpkhAddress(address) {
    return groupFromBytesForAssetAddress(address.slice(1, 33));
}
// Pay to script hash address
function groupOfP2shAddress(address) {
    return groupFromBytesForAssetAddress(address);
}
function contractIdFromAddress(address) {
    return idFromAddress(address);
}
exports.contractIdFromAddress = contractIdFromAddress;
function tokenIdFromAddress(address) {
    return idFromAddress(address);
}
exports.tokenIdFromAddress = tokenIdFromAddress;
function idFromAddress(address) {
    const decoded = (0, bs58_1.base58ToBytes)(address);
    if (decoded.length == 0)
        throw new Error('Address string is empty');
    const addressType = decoded[0];
    const addressBody = decoded.slice(1);
    if (addressType == AddressType.P2C) {
        return addressBody;
    }
    else {
        throw new Error(`Invalid contract address type: ${addressType}`);
    }
}
function groupOfPrivateKey(privateKey, keyType) {
    return groupOfAddress(addressFromPublicKey(publicKeyFromPrivateKey(privateKey, keyType), keyType));
}
exports.groupOfPrivateKey = groupOfPrivateKey;
function publicKeyFromPrivateKey(privateKey, _keyType) {
    const keyType = _keyType ?? 'default';
    if (keyType === 'default') {
        const key = ec.keyFromPrivate(privateKey);
        return key.getPublic(true, 'hex');
    }
    else {
        return ec.g.mul(new bn_js_1.default(privateKey, 16)).encode('hex', true).slice(2);
    }
}
exports.publicKeyFromPrivateKey = publicKeyFromPrivateKey;
function addressFromPublicKey(publicKey, _keyType) {
    const keyType = _keyType ?? 'default';
    if (keyType === 'default') {
        const hash = blakejs_1.default.blake2b((0, utils_1.hexToBinUnsafe)(publicKey), undefined, 32);
        const bytes = new Uint8Array([AddressType.P2PKH, ...hash]);
        return bs58_1.default.encode(bytes);
    }
    else {
        const lockupScript = (0, utils_1.hexToBinUnsafe)(`0101000000000458144020${publicKey}8685`);
        return addressFromScript(lockupScript);
    }
}
exports.addressFromPublicKey = addressFromPublicKey;
function addressFromScript(script) {
    const scriptHash = blakejs_1.default.blake2b(script, undefined, 32);
    return bs58_1.default.encode(new Uint8Array([AddressType.P2SH, ...scriptHash]));
}
exports.addressFromScript = addressFromScript;
function addressFromContractId(contractId) {
    const hash = (0, utils_1.hexToBinUnsafe)(contractId);
    const bytes = new Uint8Array([AddressType.P2C, ...hash]);
    return bs58_1.default.encode(bytes);
}
exports.addressFromContractId = addressFromContractId;
function addressFromTokenId(tokenId) {
    const contractId = tokenId; // contract ID is the same as token ID
    return addressFromContractId(contractId);
}
exports.addressFromTokenId = addressFromTokenId;
function contractIdFromTx(txId, outputIndex) {
    const txIdBin = (0, utils_1.hexToBinUnsafe)(txId);
    const data = new Uint8Array([...txIdBin, outputIndex]);
    const hash = blakejs_1.default.blake2b(data, undefined, 32);
    return (0, utils_1.binToHex)(hash);
}
exports.contractIdFromTx = contractIdFromTx;
function subContractId(parentContractId, pathInHex, group) {
    if (group < 0 || group >= constants_1.TOTAL_NUMBER_OF_GROUPS) {
        throw new Error(`Invalid group ${group}`);
    }
    if (!(0, utils_1.isHexString)(parentContractId)) {
        throw new Error(`Invalid parent contract ID: ${parentContractId}, expected hex string`);
    }
    if (!(0, utils_1.isHexString)(pathInHex)) {
        throw new Error(`Invalid path: ${pathInHex}, expected hex string`);
    }
    const data = (0, utils_1.concatBytes)([(0, utils_1.hexToBinUnsafe)(parentContractId), (0, utils_1.hexToBinUnsafe)(pathInHex)]);
    const bytes = new Uint8Array([
        ...blakejs_1.default.blake2b(blakejs_1.default.blake2b(data, undefined, 32), undefined, 32).slice(0, -1),
        group
    ]);
    return (0, utils_1.binToHex)(bytes);
}
exports.subContractId = subContractId;
function groupOfLockupScript(lockupScript) {
    if (lockupScript.kind === 'P2PKH') {
        return groupFromBytesForAssetAddress(lockupScript.value);
    }
    else if (lockupScript.kind === 'P2MPKH') {
        return groupFromBytesForAssetAddress(lockupScript.value.publicKeyHashes[0]);
    }
    else if (lockupScript.kind === 'P2SH') {
        return groupFromBytesForAssetAddress(lockupScript.value);
    }
    else {
        // P2C
        const contractId = lockupScript.value;
        return contractId[`${contractId.length - 1}`];
    }
}
exports.groupOfLockupScript = groupOfLockupScript;
function groupFromBytesForAssetAddress(bytes) {
    const hint = (0, djb2_1.default)(bytes) | 1;
    const hash = (0, utils_1.xorByte)(hint);
    return hash % constants_1.TOTAL_NUMBER_OF_GROUPS;
}
