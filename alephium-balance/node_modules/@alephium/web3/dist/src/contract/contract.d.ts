import { NamedVals, node, NodeProvider, Number256, Token, Val } from '../api';
import { SignDeployContractTxParams, SignDeployContractTxResult, SignExecuteScriptTxParams, SignerProvider, Address, SignExecuteScriptTxResult } from '../signer';
import { Optional, HexString } from '../utils';
import { EventSubscribeOptions, EventSubscription } from './events';
import { contract, Method } from '../codec';
export type FieldsSig = node.FieldsSig;
export type MapsSig = node.MapsSig;
export type EventSig = node.EventSig;
export type FunctionSig = Omit<node.FunctionSig, 'isPublic' | 'usePreapprovedAssets' | 'useAssetsInContract'>;
export type Fields = NamedVals;
export type Arguments = NamedVals;
export type Constant = node.Constant;
export type Enum = node.Enum;
export declare const StdIdFieldName = "__stdInterfaceId";
export type CompilerOptions = node.CompilerOptions & {
    errorOnWarnings: boolean;
};
export declare const DEFAULT_NODE_COMPILER_OPTIONS: node.CompilerOptions;
export declare const DEFAULT_COMPILER_OPTIONS: CompilerOptions;
export declare class Struct {
    name: string;
    fieldNames: string[];
    fieldTypes: string[];
    isMutable: boolean[];
    constructor(name: string, fieldNames: string[], fieldTypes: string[], isMutable: boolean[]);
    static fromJson(json: any): Struct;
    static fromStructSig(sig: node.StructSig): Struct;
    toJson(): any;
}
export declare abstract class Artifact {
    readonly version: string;
    readonly name: string;
    readonly functions: FunctionSig[];
    constructor(version: string, name: string, functions: FunctionSig[]);
    abstract buildByteCodeToDeploy(initialFields: Fields, isDevnet: boolean, exposePrivateFunctions: boolean): string;
    isDevnet(signer: SignerProvider): Promise<boolean>;
}
export declare class Contract extends Artifact {
    readonly bytecode: string;
    readonly bytecodeDebugPatch: string;
    readonly codeHash: string;
    readonly fieldsSig: FieldsSig;
    readonly eventsSig: EventSig[];
    readonly constants: Constant[];
    readonly enums: Enum[];
    readonly structs: Struct[];
    readonly mapsSig?: MapsSig;
    readonly stdInterfaceId?: HexString;
    readonly bytecodeDebug: string;
    readonly codeHashDebug: string;
    readonly decodedContract: contract.Contract;
    private bytecodeForTesting;
    private decodedTestingContract;
    private codeHashForTesting;
    constructor(version: string, name: string, bytecode: string, bytecodeDebugPatch: string, codeHash: string, codeHashDebug: string, fieldsSig: FieldsSig, eventsSig: EventSig[], functions: FunctionSig[], constants: Constant[], enums: Enum[], structs: Struct[], mapsSig?: MapsSig, stdInterfaceId?: HexString);
    isInlineFunc(index: number): boolean;
    getByteCodeForTesting(): string;
    getDecodedTestingContract(): contract.Contract;
    hasCodeHash(hash: string): boolean;
    getDecodedMethod(methodIndex: number): Method;
    publicFunctions(): FunctionSig[];
    usingPreapprovedAssetsFunctions(): FunctionSig[];
    usingAssetsInContractFunctions(): FunctionSig[];
    isMethodUsePreapprovedAssets(isDevnet: boolean, methodIndex: number): boolean;
    static fromJson(artifact: any, bytecodeDebugPatch?: string, codeHashDebug?: string, structs?: Struct[]): Contract;
    static fromCompileResult(result: node.CompileContractResult, structs?: Struct[]): Contract;
    static fromArtifactFile(path: string, bytecodeDebugPatch: string, codeHashDebug: string, structs?: Struct[]): Promise<Contract>;
    toString(): string;
    getInitialFieldsWithDefaultValues(): Fields;
    toState<T extends Fields>(fields: T, asset: Asset, address?: string): ContractState<T>;
    static randomAddress(): string;
    printDebugMessages(funcName: string, messages: DebugMessage[]): void;
    toApiFields(fields?: Fields): node.Val[];
    toApiArgs(funcName: string, args?: Arguments): node.Val[];
    getMethodIndex(funcName: string): number;
    toApiContractStates(states?: ContractState[]): node.ContractState[] | undefined;
    toApiTestContractParams(funcName: string, params: TestContractParams): node.TestContract;
    fromApiContractState(state: node.ContractState): ContractState<Fields>;
    static fromApiContractState(state: node.ContractState, getContractByCodeHash: (codeHash: string) => Contract): ContractState;
    static ContractCreatedEventIndex: number;
    static ContractCreatedEvent: EventSig;
    static ContractDestroyedEventIndex: number;
    static ContractDestroyedEvent: EventSig;
    static DebugEventIndex: number;
    static fromApiEvent(event: node.ContractEventByTxId, codeHash: string | undefined, txId: string, getContractByCodeHash: (codeHash: string) => Contract): ContractEvent;
    fromApiTestContractResult(methodName: string, result: node.TestContractResult, txId: string, getContractByCodeHash: (codeHash: string) => Contract): TestContractResult<unknown>;
    txParamsForDeployment<P extends Fields>(signer: SignerProvider, params: DeployContractParams<P>): Promise<SignDeployContractTxParams>;
    buildByteCodeToDeploy(initialFields: Fields, isDevnet: boolean, exposePrivateFunctions?: boolean): string;
    static fromApiEvents(events: node.ContractEventByTxId[], addressToCodeHash: Map<string, string>, txId: string, getContractByCodeHash: (codeHash: string) => Contract): ContractEvent[];
    toApiCallContract<T extends Arguments>(params: CallContractParams<T>, groupIndex: number, contractAddress: string, methodIndex: number): node.CallContract;
    fromApiCallContractResult(result: node.CallContractResult, txId: string, methodIndex: number, getContractByCodeHash: (codeHash: string) => Contract): CallContractResult<unknown>;
}
export declare class Script extends Artifact {
    readonly bytecodeTemplate: string;
    readonly bytecodeDebugPatch: string;
    readonly fieldsSig: FieldsSig;
    readonly structs: Struct[];
    constructor(version: string, name: string, bytecodeTemplate: string, bytecodeDebugPatch: string, fieldsSig: FieldsSig, functions: FunctionSig[], structs: Struct[]);
    static fromCompileResult(result: node.CompileScriptResult, structs?: Struct[]): Script;
    static fromJson(artifact: any, bytecodeDebugPatch?: string, structs?: Struct[]): Script;
    static fromArtifactFile(path: string, bytecodeDebugPatch: string, structs?: Struct[]): Promise<Script>;
    toString(): string;
    txParamsForExecution<P extends Fields>(signer: SignerProvider, params: ExecuteScriptParams<P>): Promise<SignExecuteScriptTxParams>;
    buildByteCodeToDeploy(initialFields: Fields): string;
}
export declare function fromApiFields(immFields: node.Val[], mutFields: node.Val[], fieldsSig: FieldsSig, structs: Struct[]): NamedVals;
export declare function getDefaultValue(fieldsSig: FieldsSig, structs: Struct[]): Fields;
export declare function fromApiArray(values: node.Val[], types: string[], structs: Struct[]): Val[];
export declare function fromApiEventFields(vals: node.Val[], eventSig: node.EventSig, systemEvent?: boolean): Fields;
export interface Asset {
    alphAmount: Number256;
    tokens?: Token[];
}
export interface InputAsset {
    address: string;
    asset: Asset;
}
export interface ContractState<T extends Fields = Fields> {
    address: string;
    contractId: string;
    bytecode: string;
    initialStateHash?: string;
    codeHash: string;
    fields: T;
    fieldsSig: FieldsSig;
    asset: Asset;
}
export interface ContractStateWithMaps<T extends Fields = Fields, M extends Record<string, Map<Val, Val>> = Record<string, Map<Val, Val>>> extends ContractState<T> {
    maps?: M;
}
export type TestContractParamsWithoutMaps<F extends Fields = Fields, A extends Arguments = Arguments> = Omit<TestContractParams<F, A>, 'initialMaps'>;
export interface TestContractParams<F extends Fields = Fields, A extends Arguments = Arguments, M extends Record<string, Map<Val, Val>> = Record<string, Map<Val, Val>>> {
    group?: number;
    address?: string;
    callerAddress?: string;
    blockHash?: string;
    blockTimeStamp?: number;
    txId?: string;
    initialFields: F;
    initialMaps?: M;
    initialAsset?: Asset;
    testArgs: A;
    existingContracts?: ContractStateWithMaps[];
    inputAssets?: InputAsset[];
}
export interface ContractEvent<T extends Fields = Fields> {
    txId: string;
    blockHash: string;
    contractAddress: string;
    eventIndex: number;
    name: string;
    fields: T;
}
export type DebugMessage = node.DebugMessage;
export type TestContractResultWithoutMaps<R> = Omit<TestContractResult<R>, 'maps'>;
export interface TestContractResult<R, M extends Record<string, Map<Val, Val>> = Record<string, Map<Val, Val>>> {
    contractId: string;
    contractAddress: string;
    returns: R;
    gasUsed: number;
    maps?: M;
    contracts: ContractStateWithMaps[];
    txOutputs: Output[];
    events: ContractEvent[];
    debugMessages: DebugMessage[];
}
export declare type Output = AssetOutput | ContractOutput;
export interface AssetOutput extends Asset {
    type: string;
    address: string;
    lockTime: number;
    message: string;
}
export interface ContractOutput {
    type: string;
    address: string;
    alphAmount: Number256;
    tokens?: Token[];
}
export declare function randomTxId(): string;
export interface DeployContractParams<P extends Fields = Fields> {
    initialFields: P;
    initialAttoAlphAmount?: Number256;
    initialTokenAmounts?: Token[];
    issueTokenAmount?: Number256;
    issueTokenTo?: string;
    gasAmount?: number;
    gasPrice?: Number256;
    exposePrivateFunctions?: boolean;
}
export type DeployContractResult<T extends ContractInstance> = Omit<SignDeployContractTxResult, 'contractId' | 'contractAddress' | 'groupIndex'> & {
    contractInstance: T;
};
export declare abstract class ContractFactory<I extends ContractInstance, F extends Fields = Fields> {
    readonly contract: Contract;
    constructor(contract: Contract);
    abstract at(address: string): I;
    deploy(signer: SignerProvider, deployParams: DeployContractParams<F>): Promise<DeployContractResult<I>>;
    deployTemplate(signer: SignerProvider): Promise<DeployContractResult<I>>;
    protected stateForTest_(initFields: F, asset?: Asset, address?: string, maps?: Record<string, Map<Val, Val>>): ContractState<F> | ContractStateWithMaps<F>;
}
export declare class ExecutableScript<P extends Fields = Fields, R extends Val | null = null> {
    readonly script: Script;
    readonly getContractByCodeHash: (codeHash: string) => Contract;
    constructor(script: Script, getContractByCodeHash: (codeHash: string) => Contract);
    execute(signer: SignerProvider, params: ExecuteScriptParams<P>): Promise<ExecuteScriptResult>;
    call(params: CallScriptParams<P>): Promise<CallScriptResult<R>>;
}
export interface ExecuteScriptParams<P extends Fields = Fields> {
    initialFields: P;
    attoAlphAmount?: Number256;
    tokens?: Token[];
    gasAmount?: number;
    gasPrice?: Number256;
}
export interface ExecuteScriptResult {
    groupIndex: number;
    unsignedTx: string;
    txId: string;
    signature: string;
    gasAmount: number;
    gasPrice: Number256;
}
export interface CallScriptParams<P extends Fields = Fields> {
    initialFields: P;
    groupIndex?: number;
    callerAddress?: string;
    worldStateBlockHash?: string;
    txId?: string;
    interestedContracts?: string[];
    inputAssets?: InputAsset[];
}
export type CallScriptResult<R> = CallContractResult<R>;
export interface CallContractParams<T extends Arguments = Arguments> {
    args: T;
    worldStateBlockHash?: string;
    txId?: string;
    interestedContracts?: string[];
    inputAssets?: InputAsset[];
}
export interface CallContractResult<R> {
    returns: R;
    gasUsed: number;
    contracts: ContractState[];
    txInputs: string[];
    txOutputs: Output[];
    events: ContractEvent[];
    debugMessages: DebugMessage[];
}
export interface SignExecuteContractMethodParams<T extends Arguments = Arguments> {
    args: T;
    signer: SignerProvider;
    attoAlphAmount?: Number256;
    tokens?: Token[];
    gasAmount?: number;
    gasPrice?: Number256;
}
export declare const CreateContractEventAddresses: string[];
export declare const DestroyContractEventAddresses: string[];
export type ContractCreatedEventFields = {
    address: Address;
    parentAddress?: Address;
    stdInterfaceIdGuessed?: HexString;
};
export type ContractDestroyedEventFields = {
    address: Address;
};
export type ContractCreatedEvent = ContractEvent<ContractCreatedEventFields>;
export type ContractDestroyedEvent = ContractEvent<ContractDestroyedEventFields>;
export declare function decodeContractCreatedEvent(event: node.ContractEvent): Omit<ContractCreatedEvent, 'contractAddress'>;
export declare function decodeContractDestroyedEvent(event: node.ContractEvent): Omit<ContractDestroyedEvent, 'contractAddress'>;
export declare function subscribeEventsFromContract<T extends Fields, M extends ContractEvent<T>>(options: EventSubscribeOptions<M>, address: string, eventIndex: number, decodeFunc: (event: node.ContractEvent) => M, fromCount?: number): EventSubscription;
export declare function addStdIdToFields<F extends Fields>(contract: Contract, fields: F): F | (F & {
    __stdInterfaceId: HexString;
});
export declare function extractMapsFromApiResult(selfAddress: string, params: Optional<TestContractParams, 'testArgs' | 'initialFields'>, group: number, apiResult: node.TestContractResult, getContractByCodeHash: (codeHash: string) => Contract): {
    address: string;
    maps: Record<string, Map<Val, Val>>;
}[];
export declare function testMethod<I extends ContractInstance, F extends Fields, A extends Arguments, R, M extends Record<string, Map<Val, Val>> = Record<string, Map<Val, Val>>>(factory: ContractFactory<I, F>, methodName: string, params: Optional<TestContractParams<F, A, M>, 'testArgs' | 'initialFields'>, getContractByCodeHash: (codeHash: string) => Contract): Promise<TestContractResult<R, M>>;
export declare function getDebugMessagesFromTx(txId: HexString, provider?: NodeProvider): Promise<{
    contractAddress: string;
    message: string;
}[]>;
export declare function printDebugMessagesFromTx(txId: HexString, provider?: NodeProvider): Promise<void>;
export declare class RalphMap<K extends Val, V extends Val> {
    private readonly parentContract;
    private readonly parentContractId;
    private readonly mapName;
    private readonly groupIndex;
    constructor(parentContract: Contract, parentContractId: HexString, mapName: string);
    get(key: K): Promise<V | undefined>;
    contains(key: K): Promise<boolean>;
    toJSON(): {
        parentContractId: string;
        mapName: string;
        groupIndex: number;
    };
}
export declare function getMapItem<R extends Val>(parentContract: Contract, parentContractId: HexString, groupIndex: number, mapName: string, key: Val): Promise<R | undefined>;
export declare abstract class ContractInstance {
    readonly address: Address;
    readonly contractId: string;
    readonly groupIndex: number;
    constructor(address: Address);
}
export declare function fetchContractState<F extends Fields, I extends ContractInstance>(contract: ContractFactory<I, F>, instance: ContractInstance): Promise<ContractState<F>>;
export declare function subscribeContractCreatedEvent(options: EventSubscribeOptions<ContractCreatedEvent>, fromGroup: number, fromCount?: number): EventSubscription;
export declare function subscribeContractDestroyedEvent(options: EventSubscribeOptions<ContractDestroyedEvent>, fromGroup: number, fromCount?: number): EventSubscription;
export declare function decodeEvent<F extends Fields, M extends ContractEvent<F>>(contract: Contract, instance: ContractInstance, event: node.ContractEvent, targetEventIndex: number): M;
export declare function subscribeContractEvent<F extends Fields, M extends ContractEvent<F>>(contract: Contract, instance: ContractInstance, options: EventSubscribeOptions<M>, eventName: string, fromCount?: number): EventSubscription;
export declare function subscribeContractEvents(contract: Contract, instance: ContractInstance, options: EventSubscribeOptions<ContractEvent<any>>, fromCount?: number): EventSubscription;
export declare function callMethod<I extends ContractInstance, F extends Fields, A extends Arguments, R>(contract: ContractFactory<I, F>, instance: ContractInstance, methodName: string, params: Optional<CallContractParams<A>, 'args'>, getContractByCodeHash: (codeHash: string) => Contract): Promise<CallContractResult<R>>;
export declare function signExecuteMethod<I extends ContractInstance, F extends Fields, A extends Arguments, R>(contract: ContractFactory<I, F>, instance: ContractInstance, methodName: string, params: Optional<SignExecuteContractMethodParams<A>, 'args'>): Promise<SignExecuteScriptTxResult>;
type Calls = Record<string, Optional<CallContractParams<any>, 'args'>>;
export declare function multicallMethods<I extends ContractInstance, F extends Fields>(contract: ContractFactory<I, F>, instance: ContractInstance, _callss: Calls | Calls[], getContractByCodeHash: (codeHash: string) => Contract): Promise<Record<string, CallContractResult<any>>[] | Record<string, CallContractResult<any>>>;
export declare function getContractEventsCurrentCount(contractAddress: Address): Promise<number>;
export declare const getContractIdFromUnsignedTx: (nodeProvider: NodeProvider, unsignedTx: string) => Promise<HexString>;
export declare const getTokenIdFromUnsignedTx: (nodeProvider: NodeProvider, unsignedTx: string) => Promise<HexString>;
export declare function getContractCodeByCodeHash(nodeProvider: NodeProvider, codeHash: HexString): Promise<HexString | undefined>;
export {};
