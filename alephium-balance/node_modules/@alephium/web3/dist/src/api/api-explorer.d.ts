/** AcceptedTransaction */
export interface AcceptedTransaction {
    /** @format 32-byte-hash */
    hash: string;
    /** @format block-hash */
    blockHash: string;
    /** @format int64 */
    timestamp: number;
    inputs?: Input[];
    outputs?: Output[];
    version: number;
    networkId: number;
    scriptOpt?: string;
    /** @format int32 */
    gasAmount: number;
    /** @format uint256 */
    gasPrice: string;
    scriptExecutionOk: boolean;
    inputSignatures?: string[];
    scriptSignatures?: string[];
    coinbase: boolean;
    type: string;
}
/** AddressBalance */
export interface AddressBalance {
    /** @format uint256 */
    balance: string;
    /** @format uint256 */
    lockedBalance: string;
}
/** AddressInfo */
export interface AddressInfo {
    /** @format uint256 */
    balance: string;
    /** @format uint256 */
    lockedBalance: string;
    /** @format int32 */
    txNumber: number;
}
/** AddressTokenBalance */
export interface AddressTokenBalance {
    /** @format 32-byte-hash */
    tokenId: string;
    /** @format uint256 */
    balance: string;
    /** @format uint256 */
    lockedBalance: string;
}
/** AmountHistory */
export interface AmountHistory {
    amountHistory?: string[][];
}
/** AssetOutput */
export interface AssetOutput {
    /** @format int32 */
    hint: number;
    /** @format 32-byte-hash */
    key: string;
    /** @format uint256 */
    attoAlphAmount: string;
    /** @format address */
    address: string;
    tokens?: Token[];
    /** @format int64 */
    lockTime?: number;
    /** @format hex-string */
    message?: string;
    /** @format 32-byte-hash */
    spent?: string;
    fixedOutput: boolean;
    type: string;
}
/** BadRequest */
export interface BadRequest {
    detail: string;
}
/** BlockEntry */
export interface BlockEntry {
    /** @format block-hash */
    hash: string;
    /** @format int64 */
    timestamp: number;
    /** @format group-index */
    chainFrom: number;
    /** @format group-index */
    chainTo: number;
    /** @format int32 */
    height: number;
    deps?: string[];
    /** @format hex-string */
    nonce: string;
    version: number;
    /** @format 32-byte-hash */
    depStateHash: string;
    /** @format 32-byte-hash */
    txsHash: string;
    /** @format int32 */
    txNumber: number;
    /** @format hex-string */
    target: string;
    /** @format bigint */
    hashRate: string;
    /** @format block-hash */
    parent?: string;
    mainChain: boolean;
    ghostUncles?: GhostUncle[];
}
/** BlockEntryLite */
export interface BlockEntryLite {
    /** @format block-hash */
    hash: string;
    /** @format int64 */
    timestamp: number;
    /** @format group-index */
    chainFrom: number;
    /** @format group-index */
    chainTo: number;
    /** @format int32 */
    height: number;
    /** @format int32 */
    txNumber: number;
    mainChain: boolean;
    /** @format bigint */
    hashRate: string;
}
/** ContractLiveness */
export interface ContractLiveness {
    /** @format address */
    parent?: string;
    creation: ContractLivenessLocation;
    destruction?: ContractLivenessLocation;
    interfaceId?: StdInterfaceId;
}
/** ContractLivenessLocation */
export interface ContractLivenessLocation {
    /** @format block-hash */
    blockHash: string;
    /** @format 32-byte-hash */
    txHash: string;
    /** @format int64 */
    timestamp: number;
}
/** ContractOutput */
export interface ContractOutput {
    /** @format int32 */
    hint: number;
    /** @format 32-byte-hash */
    key: string;
    /** @format uint256 */
    attoAlphAmount: string;
    /** @format address */
    address: string;
    tokens?: Token[];
    /** @format 32-byte-hash */
    spent?: string;
    fixedOutput: boolean;
    type: string;
}
/** ContractParent */
export interface ContractParent {
    /** @format address */
    parent?: string;
}
/** Event */
export interface Event {
    /** @format block-hash */
    blockHash: string;
    /** @format 32-byte-hash */
    txHash: string;
    /** @format address */
    contractAddress: string;
    /** @format address */
    inputAddress?: string;
    /** @format int32 */
    eventIndex: number;
    fields?: Val[];
}
/** ExplorerInfo */
export interface ExplorerInfo {
    releaseVersion: string;
    commit: string;
    /** @format int32 */
    migrationsVersion: number;
    /** @format int64 */
    lastFinalizedInputTime: number;
    /** @format int64 */
    lastHoldersUpdate: number;
}
/** FungibleToken */
export interface FungibleToken {
    id: string;
    type: string;
}
/** FungibleTokenMetadata */
export interface FungibleTokenMetadata {
    /** @format 32-byte-hash */
    id: string;
    symbol: string;
    name: string;
    /** @format uint256 */
    decimals: string;
}
/** GhostUncle */
export interface GhostUncle {
    /** @format block-hash */
    blockHash: string;
    /** @format address */
    miner: string;
}
/** Hashrate */
export interface Hashrate {
    /** @format int64 */
    timestamp: number;
    hashrate: number;
    value: number;
}
/** HolderInfo */
export interface HolderInfo {
    /** @format address */
    address: string;
    /** @format uint256 */
    balance: string;
}
/** Input */
export interface Input {
    outputRef: OutputRef;
    /** @format hex-string */
    unlockScript?: string;
    /** @format 32-byte-hash */
    txHashRef?: string;
    /** @format address */
    address?: string;
    /** @format uint256 */
    attoAlphAmount?: string;
    tokens?: Token[];
    contractInput: boolean;
}
/** InternalServerError */
export interface InternalServerError {
    detail: string;
}
/** IntervalType */
export declare enum IntervalType {
    Daily = "daily",
    Hourly = "hourly",
    Weekly = "weekly"
}
/** ListBlocks */
export interface ListBlocks {
    /** @format int32 */
    total: number;
    blocks?: BlockEntryLite[];
}
/** LogbackValue */
export interface LogbackValue {
    name: string;
    level: string;
}
/** MempoolTransaction */
export interface MempoolTransaction {
    /** @format 32-byte-hash */
    hash: string;
    /** @format group-index */
    chainFrom: number;
    /** @format group-index */
    chainTo: number;
    inputs?: Input[];
    outputs?: Output[];
    /** @format int32 */
    gasAmount: number;
    /** @format uint256 */
    gasPrice: string;
    /** @format int64 */
    lastSeen: number;
}
/** NFT */
export interface NFT {
    id: string;
    type: string;
}
/** NFTCollection */
export interface NFTCollection {
    type: string;
}
/** NFTCollectionMetadata */
export interface NFTCollectionMetadata {
    /** @format address */
    address: string;
    collectionUri: string;
}
/** NFTCollectionWithRoyalty */
export interface NFTCollectionWithRoyalty {
    type: string;
}
/** NFTMetadata */
export interface NFTMetadata {
    /** @format 32-byte-hash */
    id: string;
    tokenUri: string;
    /** @format 32-byte-hash */
    collectionId: string;
    /** @format uint256 */
    nftIndex: string;
}
/** NonStandard */
export interface NonStandard {
    type: string;
}
/** NotFound */
export interface NotFound {
    detail: string;
    resource: string;
}
/** Output */
export type Output = AssetOutput | ContractOutput;
/** OutputRef */
export interface OutputRef {
    /** @format int32 */
    hint: number;
    /** @format 32-byte-hash */
    key: string;
}
/** PendingTransaction */
export interface PendingTransaction {
    /** @format 32-byte-hash */
    hash: string;
    /** @format group-index */
    chainFrom: number;
    /** @format group-index */
    chainTo: number;
    inputs?: Input[];
    outputs?: Output[];
    /** @format int32 */
    gasAmount: number;
    /** @format uint256 */
    gasPrice: string;
    /** @format int64 */
    lastSeen: number;
    type: string;
}
/** PerChainCount */
export interface PerChainCount {
    /** @format int32 */
    chainFrom: number;
    /** @format int32 */
    chainTo: number;
    /** @format int64 */
    count: number;
}
/** PerChainDuration */
export interface PerChainDuration {
    /** @format int32 */
    chainFrom: number;
    /** @format int32 */
    chainTo: number;
    /** @format int64 */
    duration: number;
    /** @format int64 */
    value: number;
}
/** PerChainHeight */
export interface PerChainHeight {
    /** @format int32 */
    chainFrom: number;
    /** @format int32 */
    chainTo: number;
    /** @format int64 */
    height: number;
    /** @format int64 */
    value: number;
}
/** PerChainTimedCount */
export interface PerChainTimedCount {
    /** @format int64 */
    timestamp: number;
    totalCountPerChain?: PerChainCount[];
}
/** ServiceUnavailable */
export interface ServiceUnavailable {
    detail: string;
}
/** StdInterfaceId */
export type StdInterfaceId = FungibleToken | NFT | NFTCollection | NFTCollectionWithRoyalty | NonStandard | Unknown;
/** SubContracts */
export interface SubContracts {
    subContracts?: string[];
}
/** TimedCount */
export interface TimedCount {
    /** @format int64 */
    timestamp: number;
    /** @format int64 */
    totalCountAllChains: number;
}
/** TimedPrices */
export interface TimedPrices {
    timestamps?: number[];
    prices?: number[];
}
/** Token */
export interface Token {
    /** @format 32-byte-hash */
    id: string;
    /** @format uint256 */
    amount: string;
}
/** TokenInfo */
export interface TokenInfo {
    /** @format 32-byte-hash */
    token: string;
    /** Raw interface id, e.g. 0001 */
    stdInterfaceId?: TokenStdInterfaceId | string;
}
/** TokenStdInterfaceId */
export declare enum TokenStdInterfaceId {
    Fungible = "fungible",
    NonFungible = "non-fungible",
    NonStandard = "non-standard"
}
/** TokenSupply */
export interface TokenSupply {
    /** @format int64 */
    timestamp: number;
    /** @format uint256 */
    total: string;
    /** @format uint256 */
    circulating: string;
    /** @format uint256 */
    reserved: string;
    /** @format uint256 */
    locked: string;
    /** @format uint256 */
    maximum: string;
}
/** Transaction */
export interface Transaction {
    /** @format 32-byte-hash */
    hash: string;
    /** @format block-hash */
    blockHash: string;
    /** @format int64 */
    timestamp: number;
    inputs?: Input[];
    outputs?: Output[];
    version: number;
    networkId: number;
    scriptOpt?: string;
    /** @format int32 */
    gasAmount: number;
    /** @format uint256 */
    gasPrice: string;
    scriptExecutionOk: boolean;
    inputSignatures?: string[];
    scriptSignatures?: string[];
    coinbase: boolean;
}
/** TransactionInfo */
export interface TransactionInfo {
    /** @format 32-byte-hash */
    hash: string;
    /** @format block-hash */
    blockHash: string;
    /** @format int64 */
    timestamp: number;
    coinbase: boolean;
}
/** TransactionLike */
export type TransactionLike = AcceptedTransaction | PendingTransaction;
/** Unauthorized */
export interface Unauthorized {
    detail: string;
}
/** Unknown */
export interface Unknown {
    id: string;
    type: string;
}
/** Val */
export type Val = ValAddress | ValArray | ValBool | ValByteVec | ValI256 | ValU256;
/** ValAddress */
export interface ValAddress {
    /** @format address */
    value: string;
    type: string;
}
/** ValArray */
export interface ValArray {
    value: Val[];
    type: string;
}
/** ValBool */
export interface ValBool {
    value: boolean;
    type: string;
}
/** ValByteVec */
export interface ValByteVec {
    /** @format hex-string */
    value: string;
    type: string;
}
/** ValI256 */
export interface ValI256 {
    /** @format bigint */
    value: string;
    type: string;
}
/** ValU256 */
export interface ValU256 {
    /** @format uint256 */
    value: string;
    type: string;
}
export declare enum PaginationLimitDefault {
    Value20 = 20,
    Value10 = 10
}
export declare enum PaginationLimitMax {
    Value100 = 100,
    Value20 = 20
}
export declare enum PaginationPageDefault {
    Value1 = 1
}
export declare enum MaxSizeTokens {
    Value80 = 80
}
export declare enum MaxSizeAddressesForTokens {
    Value80 = 80
}
export declare enum MaxSizeAddresses {
    Value80 = 80
}
export declare enum Currencies {
    Btc = "btc",
    Eth = "eth",
    Usd = "usd",
    Eur = "eur",
    Chf = "chf",
    Gbp = "gbp",
    Idr = "idr",
    Vnd = "vnd",
    Rub = "rub",
    Try = "try",
    Cad = "cad",
    Aud = "aud"
}
import 'cross-fetch/polyfill';
export type QueryParamsType = Record<string | number, any>;
export type ResponseFormat = keyof Omit<Body, 'body' | 'bodyUsed'>;
export interface FullRequestParams extends Omit<RequestInit, 'body'> {
    /** set parameter to `true` for call `securityWorker` for this request */
    secure?: boolean;
    /** request path */
    path: string;
    /** content type of request body */
    type?: ContentType;
    /** query params */
    query?: QueryParamsType;
    /** format of response (i.e. response.json() -> format: "json") */
    format?: ResponseFormat;
    /** request body */
    body?: unknown;
    /** base url */
    baseUrl?: string;
    /** request cancellation token */
    cancelToken?: CancelToken;
}
export type RequestParams = Omit<FullRequestParams, 'body' | 'method' | 'query' | 'path'>;
export interface ApiConfig<SecurityDataType = unknown> {
    baseUrl?: string;
    baseApiParams?: Omit<RequestParams, 'baseUrl' | 'cancelToken' | 'signal'>;
    securityWorker?: (securityData: SecurityDataType | null) => Promise<RequestParams | void> | RequestParams | void;
    customFetch?: typeof fetch;
}
export interface HttpResponse<D extends unknown, E extends unknown = unknown> extends Response {
    data: D;
    error: E;
}
type CancelToken = Symbol | string | number;
export declare enum ContentType {
    Json = "application/json",
    FormData = "multipart/form-data",
    UrlEncoded = "application/x-www-form-urlencoded",
    Text = "text/plain"
}
export declare class HttpClient<SecurityDataType = unknown> {
    baseUrl: string;
    private securityData;
    private securityWorker?;
    private abortControllers;
    private customFetch;
    private baseApiParams;
    constructor(apiConfig?: ApiConfig<SecurityDataType>);
    setSecurityData: (data: SecurityDataType | null) => void;
    protected encodeQueryParam(key: string, value: any): string;
    protected addQueryParam(query: QueryParamsType, key: string): string;
    protected addArrayQueryParam(query: QueryParamsType, key: string): any;
    protected toQueryString(rawQuery?: QueryParamsType): string;
    protected addQueryParams(rawQuery?: QueryParamsType): string;
    private contentFormatters;
    protected mergeRequestParams(params1: RequestParams, params2?: RequestParams): RequestParams;
    protected createAbortSignal: (cancelToken: CancelToken) => AbortSignal | undefined;
    abortRequest: (cancelToken: CancelToken) => void;
    request: <T = any, E = any>({ body, secure, path, type, query, format, baseUrl, cancelToken, ...params }: FullRequestParams) => Promise<HttpResponse<T, E>>;
}
/**
 * @title Alephium Explorer API
 * @version 1.0
 */
export declare class Api<SecurityDataType extends unknown> extends HttpClient<SecurityDataType> {
    blocks: {
        /**
         * @description List latest blocks
         *
         * @tags Blocks
         * @name GetBlocks
         * @request GET:/blocks
         */
        getBlocks: (query?: {
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
            /** Reverse pagination */
            reverse?: boolean;
        }, params?: RequestParams) => Promise<ListBlocks>;
        /**
         * @description Get a block with hash
         *
         * @tags Blocks
         * @name GetBlocksBlockHash
         * @request GET:/blocks/{block_hash}
         */
        getBlocksBlockHash: (blockHash: string, params?: RequestParams) => Promise<BlockEntry>;
        /**
         * @description Get block's transactions
         *
         * @tags Blocks
         * @name GetBlocksBlockHashTransactions
         * @request GET:/blocks/{block_hash}/transactions
         */
        getBlocksBlockHashTransactions: (blockHash: string, query?: {
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
        }, params?: RequestParams) => Promise<Transaction[]>;
    };
    transactions: {
        /**
         * @description Get a transaction with hash
         *
         * @tags Transactions
         * @name GetTransactionsTransactionHash
         * @request GET:/transactions/{transaction_hash}
         */
        getTransactionsTransactionHash: (transactionHash: string, params?: RequestParams) => Promise<AcceptedTransaction | PendingTransaction>;
    };
    addresses: {
        /**
         * @description Get address information
         *
         * @tags Addresses
         * @name GetAddressesAddress
         * @request GET:/addresses/{address}
         */
        getAddressesAddress: (address: string, params?: RequestParams) => Promise<AddressInfo>;
        /**
         * @description List transactions of a given address
         *
         * @tags Addresses
         * @name GetAddressesAddressTransactions
         * @request GET:/addresses/{address}/transactions
         */
        getAddressesAddressTransactions: (address: string, query?: {
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
        }, params?: RequestParams) => Promise<Transaction[]>;
        /**
         * @description List transactions for given addresses
         *
         * @tags Addresses
         * @name PostAddressesTransactions
         * @request POST:/addresses/transactions
         */
        postAddressesTransactions: (query?: {
            /**
             * inclusive
             * @format int64
             * @min 0
             */
            fromTs?: number;
            /**
             * exclusive
             * @format int64
             * @min 0
             */
            toTs?: number;
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
        }, data?: string[], params?: RequestParams) => Promise<Transaction[]>;
        /**
         * @description List transactions of a given address within a time-range
         *
         * @tags Addresses
         * @name GetAddressesAddressTimerangedTransactions
         * @request GET:/addresses/{address}/timeranged-transactions
         */
        getAddressesAddressTimerangedTransactions: (address: string, query: {
            /**
             * @format int64
             * @min 0
             */
            fromTs: number;
            /**
             * @format int64
             * @min 0
             */
            toTs: number;
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
        }, params?: RequestParams) => Promise<Transaction[]>;
        /**
         * @description Get total transactions of a given address
         *
         * @tags Addresses
         * @name GetAddressesAddressTotalTransactions
         * @request GET:/addresses/{address}/total-transactions
         */
        getAddressesAddressTotalTransactions: (address: string, params?: RequestParams) => Promise<number>;
        /**
         * @description Get latest transaction information of a given address
         *
         * @tags Addresses
         * @name GetAddressesAddressLatestTransaction
         * @request GET:/addresses/{address}/latest-transaction
         */
        getAddressesAddressLatestTransaction: (address: string, params?: RequestParams) => Promise<TransactionInfo>;
        /**
         * @description List mempool transactions of a given address
         *
         * @tags Addresses
         * @name GetAddressesAddressMempoolTransactions
         * @request GET:/addresses/{address}/mempool/transactions
         */
        getAddressesAddressMempoolTransactions: (address: string, params?: RequestParams) => Promise<MempoolTransaction[]>;
        /**
         * @description Get address balance
         *
         * @tags Addresses
         * @name GetAddressesAddressBalance
         * @request GET:/addresses/{address}/balance
         */
        getAddressesAddressBalance: (address: string, params?: RequestParams) => Promise<AddressBalance>;
        /**
         * @description List address tokens
         *
         * @tags Addresses
         * @name GetAddressesAddressTokens
         * @request GET:/addresses/{address}/tokens
         * @deprecated
         */
        getAddressesAddressTokens: (address: string, query?: {
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
        }, params?: RequestParams) => Promise<string[]>;
        /**
         * @description List address tokens
         *
         * @tags Addresses
         * @name GetAddressesAddressTokensTokenIdTransactions
         * @request GET:/addresses/{address}/tokens/{token_id}/transactions
         */
        getAddressesAddressTokensTokenIdTransactions: (address: string, tokenId: string, query?: {
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
        }, params?: RequestParams) => Promise<Transaction[]>;
        /**
         * @description Get address balance of given token
         *
         * @tags Addresses
         * @name GetAddressesAddressTokensTokenIdBalance
         * @request GET:/addresses/{address}/tokens/{token_id}/balance
         */
        getAddressesAddressTokensTokenIdBalance: (address: string, tokenId: string, params?: RequestParams) => Promise<AddressTokenBalance>;
        /**
         * @description Get public key of p2pkh addresses, the address needs to have at least one input.
         *
         * @tags Addresses
         * @name GetAddressesAddressPublicKey
         * @request GET:/addresses/{address}/public-key
         */
        getAddressesAddressPublicKey: (address: string, params?: RequestParams) => Promise<string>;
        /**
         * @description Get address tokens with balance
         *
         * @tags Addresses
         * @name GetAddressesAddressTokensBalance
         * @request GET:/addresses/{address}/tokens-balance
         */
        getAddressesAddressTokensBalance: (address: string, query?: {
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
        }, params?: RequestParams) => Promise<AddressTokenBalance[]>;
        /**
         * @description Are the addresses used (at least 1 transaction)
         *
         * @tags Addresses, Addresses
         * @name PostAddressesUsed
         * @request POST:/addresses/used
         */
        postAddressesUsed: (data?: string[], params?: RequestParams) => Promise<boolean[]>;
        /**
         * No description
         *
         * @tags Addresses
         * @name GetAddressesAddressExportTransactionsCsv
         * @request GET:/addresses/{address}/export-transactions/csv
         */
        getAddressesAddressExportTransactionsCsv: (address: string, query: {
            /**
             * @format int64
             * @min 0
             */
            fromTs: number;
            /**
             * @format int64
             * @min 0
             */
            toTs: number;
        }, params?: RequestParams) => Promise<string>;
        /**
         * No description
         *
         * @tags Addresses
         * @name GetAddressesAddressAmountHistoryDeprecated
         * @request GET:/addresses/{address}/amount-history-DEPRECATED
         * @deprecated
         */
        getAddressesAddressAmountHistoryDeprecated: (address: string, query: {
            /**
             * @format int64
             * @min 0
             */
            fromTs: number;
            /**
             * @format int64
             * @min 0
             */
            toTs: number;
            'interval-type': IntervalType;
        }, params?: RequestParams) => Promise<string>;
        /**
         * No description
         *
         * @tags Addresses
         * @name GetAddressesAddressAmountHistory
         * @request GET:/addresses/{address}/amount-history
         */
        getAddressesAddressAmountHistory: (address: string, query: {
            /**
             * @format int64
             * @min 0
             */
            fromTs: number;
            /**
             * @format int64
             * @min 0
             */
            toTs: number;
            'interval-type': IntervalType;
        }, params?: RequestParams) => Promise<AmountHistory>;
    };
    infos: {
        /**
         * @description Get explorer informations
         *
         * @tags Infos
         * @name GetInfos
         * @request GET:/infos
         */
        getInfos: (params?: RequestParams) => Promise<ExplorerInfo>;
        /**
         * @description List latest height for each chain
         *
         * @tags Infos
         * @name GetInfosHeights
         * @request GET:/infos/heights
         */
        getInfosHeights: (params?: RequestParams) => Promise<PerChainHeight[]>;
        /**
         * @description Get token supply list
         *
         * @tags Infos
         * @name GetInfosSupply
         * @request GET:/infos/supply
         */
        getInfosSupply: (query?: {
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
        }, params?: RequestParams) => Promise<TokenSupply[]>;
        /**
         * @description Get the ALPH total supply
         *
         * @tags Infos
         * @name GetInfosSupplyTotalAlph
         * @request GET:/infos/supply/total-alph
         */
        getInfosSupplyTotalAlph: (params?: RequestParams) => Promise<number>;
        /**
         * @description Get the ALPH circulating supply
         *
         * @tags Infos
         * @name GetInfosSupplyCirculatingAlph
         * @request GET:/infos/supply/circulating-alph
         */
        getInfosSupplyCirculatingAlph: (params?: RequestParams) => Promise<number>;
        /**
         * @description Get the ALPH reserved supply
         *
         * @tags Infos
         * @name GetInfosSupplyReservedAlph
         * @request GET:/infos/supply/reserved-alph
         */
        getInfosSupplyReservedAlph: (params?: RequestParams) => Promise<number>;
        /**
         * @description Get the ALPH locked supply
         *
         * @tags Infos
         * @name GetInfosSupplyLockedAlph
         * @request GET:/infos/supply/locked-alph
         */
        getInfosSupplyLockedAlph: (params?: RequestParams) => Promise<number>;
        /**
         * @description Get the total number of transactions
         *
         * @tags Infos
         * @name GetInfosTotalTransactions
         * @request GET:/infos/total-transactions
         */
        getInfosTotalTransactions: (params?: RequestParams) => Promise<number>;
        /**
         * @description Get the average block time for each chain
         *
         * @tags Infos
         * @name GetInfosAverageBlockTimes
         * @request GET:/infos/average-block-times
         */
        getInfosAverageBlockTimes: (params?: RequestParams) => Promise<PerChainDuration[]>;
    };
    mempool: {
        /**
         * @description list mempool transactions
         *
         * @tags Mempool
         * @name GetMempoolTransactions
         * @request GET:/mempool/transactions
         */
        getMempoolTransactions: (query?: {
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
        }, params?: RequestParams) => Promise<MempoolTransaction[]>;
    };
    tokens: {
        /**
         * @description List token information
         *
         * @tags Tokens
         * @name GetTokens
         * @request GET:/tokens
         */
        getTokens: (query?: {
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
            /**
             * fungible, non-fungible, non-standard or any interface id in hex-string format, e.g: 0001
             * @format string
             */
            'interface-id'?: TokenStdInterfaceId | string;
        }, params?: RequestParams) => Promise<TokenInfo[]>;
        /**
         * @description List given tokens information
         *
         * @tags Tokens
         * @name PostTokens
         * @request POST:/tokens
         */
        postTokens: (data?: string[], params?: RequestParams) => Promise<TokenInfo[]>;
        /**
         * @description List token transactions
         *
         * @tags Tokens
         * @name GetTokensTokenIdTransactions
         * @request GET:/tokens/{token_id}/transactions
         */
        getTokensTokenIdTransactions: (tokenId: string, query?: {
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
        }, params?: RequestParams) => Promise<Transaction[]>;
        /**
         * @description List token addresses
         *
         * @tags Tokens
         * @name GetTokensTokenIdAddresses
         * @request GET:/tokens/{token_id}/addresses
         */
        getTokensTokenIdAddresses: (tokenId: string, query?: {
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
        }, params?: RequestParams) => Promise<string[]>;
        /**
         * @description Return metadata for the given fungible tokens, if metadata doesn't exist or token isn't a fungible, it won't be in the output list
         *
         * @tags Tokens
         * @name PostTokensFungibleMetadata
         * @request POST:/tokens/fungible-metadata
         */
        postTokensFungibleMetadata: (data?: string[], params?: RequestParams) => Promise<FungibleTokenMetadata[]>;
        /**
         * @description Return metadata for the given nft tokens, if metadata doesn't exist or token isn't a nft, it won't be in the output list
         *
         * @tags Tokens
         * @name PostTokensNftMetadata
         * @request POST:/tokens/nft-metadata
         */
        postTokensNftMetadata: (data?: string[], params?: RequestParams) => Promise<NFTMetadata[]>;
        /**
         * @description Return metadata for the given nft collection addresses, if metadata doesn't exist or address isn't a nft collection, it won't be in the output list
         *
         * @tags Tokens
         * @name PostTokensNftCollectionMetadata
         * @request POST:/tokens/nft-collection-metadata
         */
        postTokensNftCollectionMetadata: (data?: string[], params?: RequestParams) => Promise<NFTCollectionMetadata[]>;
        /**
         * @description Get a sorted list of top addresses by ALPH balance. Updates once per day.
         *
         * @tags Tokens
         * @name GetTokensHoldersAlph
         * @request GET:/tokens/holders/alph
         */
        getTokensHoldersAlph: (query?: {
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HolderInfo[]>;
        /**
         * @description Get a sorted list of top addresses by {token_id} balance. Updates once per day.
         *
         * @tags Tokens
         * @name GetTokensHoldersTokenTokenId
         * @request GET:/tokens/holders/token/{token_id}
         */
        getTokensHoldersTokenTokenId: (tokenId: string, query?: {
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HolderInfo[]>;
    };
    charts: {
        /**
         * @description `interval-type` query param: hourly, daily
         *
         * @tags Charts
         * @name GetChartsHashrates
         * @summary Get hashrate chart in H/s
         * @request GET:/charts/hashrates
         */
        getChartsHashrates: (query: {
            /**
             * @format int64
             * @min 0
             */
            fromTs: number;
            /**
             * @format int64
             * @min 0
             */
            toTs: number;
            'interval-type': IntervalType;
        }, params?: RequestParams) => Promise<Hashrate[]>;
        /**
         * @description `interval-type` query param: hourly, daily
         *
         * @tags Charts
         * @name GetChartsTransactionsCount
         * @summary Get transaction count history
         * @request GET:/charts/transactions-count
         */
        getChartsTransactionsCount: (query: {
            /**
             * @format int64
             * @min 0
             */
            fromTs: number;
            /**
             * @format int64
             * @min 0
             */
            toTs: number;
            'interval-type': IntervalType;
        }, params?: RequestParams) => Promise<TimedCount[]>;
        /**
         * @description `interval-type` query param: hourly, daily
         *
         * @tags Charts
         * @name GetChartsTransactionsCountPerChain
         * @summary Get transaction count history per chain
         * @request GET:/charts/transactions-count-per-chain
         */
        getChartsTransactionsCountPerChain: (query: {
            /**
             * @format int64
             * @min 0
             */
            fromTs: number;
            /**
             * @format int64
             * @min 0
             */
            toTs: number;
            'interval-type': IntervalType;
        }, params?: RequestParams) => Promise<PerChainTimedCount[]>;
    };
    contractEvents: {
        /**
         * @description Get contract events by transaction id
         *
         * @tags Contract events
         * @name GetContractEventsTransactionIdTransactionId
         * @request GET:/contract-events/transaction-id/{transaction_id}
         */
        getContractEventsTransactionIdTransactionId: (transactionId: string, params?: RequestParams) => Promise<Event[]>;
        /**
         * @description Get contract events by contract address
         *
         * @tags Contract events
         * @name GetContractEventsContractAddressContractAddress
         * @request GET:/contract-events/contract-address/{contract_address}
         */
        getContractEventsContractAddressContractAddress: (contractAddress: string, query?: {
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
        }, params?: RequestParams) => Promise<Event[]>;
        /**
         * @description Get contract events by contract and input addresses
         *
         * @tags Contract events
         * @name GetContractEventsContractAddressContractAddressInputAddressInputAddress
         * @request GET:/contract-events/contract-address/{contract_address}/input-address/{input_address}
         */
        getContractEventsContractAddressContractAddressInputAddressInputAddress: (contractAddress: string, inputAddress: string, query?: {
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
        }, params?: RequestParams) => Promise<Event[]>;
    };
    contracts: {
        /**
         * @description Get contract liveness
         *
         * @tags Contracts
         * @name GetContractsContractAddressCurrentLiveness
         * @request GET:/contracts/{contract_address}/current-liveness
         */
        getContractsContractAddressCurrentLiveness: (contractAddress: string, params?: RequestParams) => Promise<ContractLiveness>;
        /**
         * @description Get contract parent address if exist
         *
         * @tags Contracts
         * @name GetContractsContractAddressParent
         * @request GET:/contracts/{contract_address}/parent
         */
        getContractsContractAddressParent: (contractAddress: string, params?: RequestParams) => Promise<ContractParent>;
        /**
         * @description Get sub contract addresses
         *
         * @tags Contracts
         * @name GetContractsContractAddressSubContracts
         * @request GET:/contracts/{contract_address}/sub-contracts
         */
        getContractsContractAddressSubContracts: (contractAddress: string, query?: {
            /**
             * Page number
             * @format int32
             * @min 1
             */
            page?: number;
            /**
             * Number of items per page
             * @format int32
             * @min 0
             * @max 100
             */
            limit?: number;
        }, params?: RequestParams) => Promise<SubContracts>;
    };
    market: {
        /**
         * No description
         *
         * @tags Market
         * @name PostMarketPrices
         * @request POST:/market/prices
         */
        postMarketPrices: (query: {
            currency: string;
        }, data?: string[], params?: RequestParams) => Promise<number[]>;
        /**
         * No description
         *
         * @tags Market
         * @name GetMarketPricesSymbolCharts
         * @request GET:/market/prices/{symbol}/charts
         */
        getMarketPricesSymbolCharts: (symbol: string, query: {
            currency: string;
        }, params?: RequestParams) => Promise<TimedPrices>;
    };
    utils: {
        /**
         * @description Perform a sanity check
         *
         * @tags Utils
         * @name PutUtilsSanityCheck
         * @request PUT:/utils/sanity-check
         */
        putUtilsSanityCheck: (params?: RequestParams) => Promise<void>;
        /**
         * @description Update global log level, accepted: TRACE, DEBUG, INFO, WARN, ERROR
         *
         * @tags Utils
         * @name PutUtilsUpdateGlobalLoglevel
         * @request PUT:/utils/update-global-loglevel
         */
        putUtilsUpdateGlobalLoglevel: (data: 'TRACE' | 'DEBUG' | 'INFO' | 'WARN' | 'ERROR', params?: RequestParams) => Promise<void>;
        /**
         * @description Update logback values
         *
         * @tags Utils
         * @name PutUtilsUpdateLogConfig
         * @request PUT:/utils/update-log-config
         */
        putUtilsUpdateLogConfig: (data?: LogbackValue[], params?: RequestParams) => Promise<void>;
    };
}
export {};
