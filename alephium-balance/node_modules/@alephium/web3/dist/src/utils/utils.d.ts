import { ec as EC, SignatureInput } from 'elliptic';
import BN from 'bn.js';
export declare const networkIds: readonly ["mainnet", "testnet", "devnet"];
export type NetworkId = (typeof networkIds)[number];
export type HexString = string;
export declare function encodeSignature(signature: EC.Signature | {
    r: BN;
    s: BN;
}): string;
export declare function encodeHexSignature(rHex: string, sHex: string): string;
export declare function signatureDecode(ec: EC, signature: string): SignatureInput;
export declare function isHexString(input: string): boolean;
export declare function toNonNegativeBigInt(input: string): bigint | undefined;
export declare function hexToBinUnsafe(hex: string): Uint8Array;
export declare function binToHex(bin: Uint8Array): string;
export declare function blockChainIndex(blockHash: HexString): {
    fromGroup: number;
    toGroup: number;
};
export declare function stringToHex(str: string): string;
export declare function hexToString(str: string): string;
export declare function sleep(ms: number): Promise<void>;
export declare function isDevnet(networkId?: number): boolean;
export declare function targetToDifficulty(compactedTarget: HexString): bigint;
export declare function difficultyToTarget(diff: bigint): HexString;
export declare function concatBytes(arrays: Uint8Array[]): Uint8Array;
export declare function xorByte(intValue: number): number;
type _Eq<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? true : false;
export type Eq<X, Y> = _Eq<{
    [P in keyof X]: X[P];
}, {
    [P in keyof Y]: Y[P];
}>;
export declare function assertType<T extends true>(): void;
export type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;
export type Narrow<type> = (unknown extends type ? unknown : never) | (type extends Function ? type : never) | (type extends bigint | boolean | number | string ? type : never) | (type extends [] ? [] : never) | {
    [K in keyof type]: Narrow<type[K]>;
};
export {};
