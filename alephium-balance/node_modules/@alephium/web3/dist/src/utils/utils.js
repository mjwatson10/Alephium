"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertType = exports.xorByte = exports.concatBytes = exports.difficultyToTarget = exports.targetToDifficulty = exports.isDevnet = exports.sleep = exports.hexToString = exports.stringToHex = exports.blockChainIndex = exports.binToHex = exports.hexToBinUnsafe = exports.toNonNegativeBigInt = exports.isHexString = exports.signatureDecode = exports.encodeHexSignature = exports.encodeSignature = exports.networkIds = void 0;
const elliptic_1 = require("elliptic");
const bn_js_1 = __importDefault(require("bn.js"));
const constants_1 = require("../constants");
exports.networkIds = ['mainnet', 'testnet', 'devnet'];
const ec = new elliptic_1.ec('secp256k1');
function encodeSignature(signature) {
    let sNormalized = signature.s;
    if (ec.n && signature.s.cmp(ec.nh) === 1) {
        sNormalized = ec.n.sub(signature.s);
    }
    const r = signature.r.toString('hex', 66).slice(2);
    const s = sNormalized.toString('hex', 66).slice(2);
    return r + s;
}
exports.encodeSignature = encodeSignature;
function encodeHexSignature(rHex, sHex) {
    return encodeSignature({ r: new bn_js_1.default(rHex, 'hex'), s: new bn_js_1.default(sHex, 'hex') });
}
exports.encodeHexSignature = encodeHexSignature;
// the signature should be in hex string format for 64 bytes
function signatureDecode(ec, signature) {
    if (signature.length !== 128) {
        throw new Error('Invalid signature length');
    }
    const sHex = signature.slice(64, 128);
    const s = new bn_js_1.default(sHex, 'hex');
    if (ec.n && s.cmp(ec.nh) < 1) {
        const decoded = { r: signature.slice(0, 64), s: sHex };
        return decoded;
    }
    else {
        throw new Error('The signature is not normalized');
    }
}
exports.signatureDecode = signatureDecode;
function isHexString(input) {
    return input.length % 2 === 0 && /^[0-9a-fA-F]*$/.test(input);
}
exports.isHexString = isHexString;
function toNonNegativeBigInt(input) {
    try {
        const bigIntValue = BigInt(input);
        return bigIntValue < 0n ? undefined : bigIntValue;
    }
    catch {
        return undefined;
    }
}
exports.toNonNegativeBigInt = toNonNegativeBigInt;
function hexToBinUnsafe(hex) {
    const bytes = [];
    for (let i = 0; i < hex.length; i += 2) {
        bytes.push(parseInt(hex.slice(i, i + 2), 16));
    }
    return new Uint8Array(bytes);
}
exports.hexToBinUnsafe = hexToBinUnsafe;
function binToHex(bin) {
    return Array.from(bin)
        .map((byte) => byte.toString(16).padStart(2, '0'))
        .join('');
}
exports.binToHex = binToHex;
function blockChainIndex(blockHash) {
    if (blockHash.length != 64) {
        throw Error(`Invalid block hash: ${blockHash}`);
    }
    const rawIndex = Number('0x' + blockHash.slice(-4)) % constants_1.TOTAL_NUMBER_OF_CHAINS;
    return { fromGroup: Math.floor(rawIndex / constants_1.TOTAL_NUMBER_OF_GROUPS), toGroup: rawIndex % constants_1.TOTAL_NUMBER_OF_GROUPS };
}
exports.blockChainIndex = blockChainIndex;
function stringToHex(str) {
    let hex = '';
    for (let i = 0; i < str.length; i++) {
        hex += '' + str.charCodeAt(i).toString(16);
    }
    return hex;
}
exports.stringToHex = stringToHex;
function hexToString(str) {
    if (!isHexString(str)) {
        throw new Error(`Invalid hex string: ${str}`);
    }
    const bytes = hexToBinUnsafe(str);
    return new TextDecoder().decode(bytes);
}
exports.hexToString = hexToString;
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
exports.sleep = sleep;
function isDevnet(networkId) {
    return networkId !== 0 && networkId !== 1;
}
exports.isDevnet = isDevnet;
function targetToDifficulty(compactedTarget) {
    if (!isHexString(compactedTarget) || compactedTarget.length !== 8) {
        throw Error(`Invalid target ${compactedTarget}, expected a hex string of length 8`);
    }
    const size = hexToBinUnsafe(compactedTarget.slice(0, 2))[0];
    const mantissa = BigInt('0x' + compactedTarget.slice(2));
    const maxBigInt = 1n << 256n;
    const target = size <= 3 ? mantissa >> BigInt(8 * (3 - size)) : mantissa << BigInt(8 * (size - 3));
    return maxBigInt / target;
}
exports.targetToDifficulty = targetToDifficulty;
function difficultyToTarget(diff) {
    const maxBigInt = 1n << 256n;
    const target = diff === 1n ? maxBigInt - 1n : maxBigInt / diff;
    const size = Math.floor((target.toString(2).length + 7) / 8);
    const mantissa = Number(size <= 3
        ? BigInt.asIntN(32, target) << BigInt(8 * (3 - size))
        : BigInt.asIntN(32, target >> BigInt(8 * (size - 3))));
    const mantissaBytes = new Uint8Array(4);
    mantissaBytes[0] = size;
    mantissaBytes[1] = (mantissa >> 16) & 0xff;
    mantissaBytes[2] = (mantissa >> 8) & 0xff;
    mantissaBytes[3] = mantissa & 0xff;
    return binToHex(mantissaBytes);
}
exports.difficultyToTarget = difficultyToTarget;
function concatBytes(arrays) {
    const totalLength = arrays.reduce((acc, arr) => acc + arr.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const array of arrays) {
        result.set(array, offset);
        offset += array.length;
    }
    return result;
}
exports.concatBytes = concatBytes;
function xorByte(intValue) {
    const byte0 = (intValue >> 24) & 0xff;
    const byte1 = (intValue >> 16) & 0xff;
    const byte2 = (intValue >> 8) & 0xff;
    const byte3 = intValue & 0xff;
    return (byte0 ^ byte1 ^ byte2 ^ byte3) & 0xff;
}
exports.xorByte = xorByte;
// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
function assertType() { }
exports.assertType = assertType;
