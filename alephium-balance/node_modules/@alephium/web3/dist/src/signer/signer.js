"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromApiDestination = exports.toApiDestinations = exports.toApiDestination = exports.verifySignedMessage = exports.hashMessage = exports.extendMessage = exports.SignerProviderWithCachedAccounts = exports.SignerProviderWithMultipleAccounts = exports.SignerProviderSimple = exports.InteractiveSignerProvider = exports.SignerProvider = void 0;
const crypto_1 = require("crypto");
const api_1 = require("../api");
const utils = __importStar(require("../utils"));
const blakejs_1 = __importDefault(require("blakejs"));
const tx_builder_1 = require("./tx-builder");
const address_1 = require("../address");
class SignerProvider {
    async getSelectedAccount() {
        const account = await this.unsafeGetSelectedAccount();
        SignerProvider.validateAccount(account);
        return account;
    }
    static validateAccount(account) {
        const derivedAddress = (0, address_1.addressFromPublicKey)(account.publicKey, account.keyType);
        const derivedGroup = (0, address_1.groupOfAddress)(derivedAddress);
        if (derivedAddress !== account.address || derivedGroup !== account.group) {
            throw Error(`Invalid accounot data: ${JSON.stringify(account)}`);
        }
    }
}
exports.SignerProvider = SignerProvider;
// Abstraction for interactive signer (e.g. WalletConnect instance, Extension wallet object)
class InteractiveSignerProvider extends SignerProvider {
    async enable(opt) {
        const account = await this.unsafeEnable(opt);
        SignerProvider.validateAccount(account);
        return account;
    }
}
exports.InteractiveSignerProvider = InteractiveSignerProvider;
class SignerProviderSimple extends SignerProvider {
    async submitTransaction(params) {
        const data = { unsignedTx: params.unsignedTx, signature: params.signature };
        return this.nodeProvider.transactions.postTransactionsSubmit(data);
    }
    async signAndSubmitTransferTx(params) {
        const signResult = await this.signTransferTx(params);
        await this.submitTransaction(signResult);
        return signResult;
    }
    async signAndSubmitDeployContractTx(params) {
        const signResult = await this.signDeployContractTx(params);
        await this.submitTransaction(signResult);
        return signResult;
    }
    async signAndSubmitExecuteScriptTx(params) {
        const signResult = await this.signExecuteScriptTx(params);
        await this.submitTransaction(signResult);
        return signResult;
    }
    async signAndSubmitUnsignedTx(params) {
        const signResult = await this.signUnsignedTx(params);
        await this.submitTransaction(signResult);
        return signResult;
    }
    async signAndSubmitChainedTx(params) {
        const signResults = await this.signChainedTx(params);
        for (const r of signResults) {
            await this.submitTransaction(r);
        }
        return signResults;
    }
    async signTransferTx(params) {
        const response = await this.buildTransferTx(params);
        const signature = await this.signRaw(params.signerAddress, response.txId);
        return { signature, ...response };
    }
    async buildTransferTx(params) {
        return tx_builder_1.TransactionBuilder.from(this.nodeProvider).buildTransferTx(params, await this.getPublicKey(params.signerAddress));
    }
    async signDeployContractTx(params) {
        const response = await this.buildDeployContractTx(params);
        const signature = await this.signRaw(params.signerAddress, response.txId);
        return { signature, ...response };
    }
    async buildDeployContractTx(params) {
        return tx_builder_1.TransactionBuilder.from(this.nodeProvider).buildDeployContractTx(params, await this.getPublicKey(params.signerAddress));
    }
    async signExecuteScriptTx(params) {
        const response = await this.buildExecuteScriptTx(params);
        const signature = await this.signRaw(params.signerAddress, response.txId);
        return { signature, ...response };
    }
    async buildExecuteScriptTx(params) {
        return tx_builder_1.TransactionBuilder.from(this.nodeProvider).buildExecuteScriptTx(params, await this.getPublicKey(params.signerAddress));
    }
    async signChainedTx(params) {
        const response = await this.buildChainedTx(params);
        const signatures = await Promise.all(response.map((r, i) => this.signRaw(params[`${i}`].signerAddress, r.txId)));
        return response.map((r, i) => ({ ...r, signature: signatures[`${i}`] }));
    }
    async buildChainedTx(params) {
        return tx_builder_1.TransactionBuilder.from(this.nodeProvider).buildChainedTx(params, await Promise.all(params.map((p) => this.getPublicKey(p.signerAddress))));
    }
    // in general, wallet should show the decoded information to user for confirmation
    // please overwrite this function for real wallet
    async signUnsignedTx(params) {
        const response = tx_builder_1.TransactionBuilder.buildUnsignedTx(params);
        const signature = await this.signRaw(params.signerAddress, response.txId);
        return { signature, ...response };
    }
    async signMessage(params) {
        const messageHash = hashMessage(params.message, params.messageHasher);
        const signature = await this.signRaw(params.signerAddress, messageHash);
        return { signature: signature };
    }
}
exports.SignerProviderSimple = SignerProviderSimple;
class SignerProviderWithMultipleAccounts extends SignerProviderSimple {
    async getAccount(signerAddress) {
        const accounts = await this.getAccounts();
        const account = accounts.find((a) => a.address === signerAddress);
        if (typeof account === 'undefined') {
            throw new Error('Unmatched signerAddress');
        }
        else {
            return account;
        }
    }
    async getPublicKey(signerAddress) {
        const account = await this.getAccount(signerAddress);
        return account.publicKey;
    }
}
exports.SignerProviderWithMultipleAccounts = SignerProviderWithMultipleAccounts;
class SignerProviderWithCachedAccounts extends SignerProviderWithMultipleAccounts {
    constructor() {
        super(...arguments);
        this._selectedAccount = undefined;
        this._accounts = new Map();
    }
    unsafeGetSelectedAccount() {
        if (this._selectedAccount === undefined) {
            throw Error('No account is selected yet');
        }
        else {
            return Promise.resolve(this._selectedAccount);
        }
    }
    setSelectedAccount(address) {
        const accountOpt = this._accounts.get(address);
        if (accountOpt === undefined) {
            throw Error('The address is not in the accounts');
        }
        else {
            this._selectedAccount = accountOpt;
            return Promise.resolve();
        }
    }
    getAccounts() {
        return Promise.resolve(Array.from(this._accounts.values()));
    }
    async getAccount(address) {
        const account = this._accounts.get(address);
        if (account === undefined) {
            throw Error('The address is not in the accounts');
        }
        return Promise.resolve(account);
    }
}
exports.SignerProviderWithCachedAccounts = SignerProviderWithCachedAccounts;
function extendMessage(message) {
    return 'Alephium Signed Message: ' + message;
}
exports.extendMessage = extendMessage;
function hashMessage(message, hasher) {
    switch (hasher) {
        case 'alephium':
            return utils.binToHex(blakejs_1.default.blake2b(extendMessage(message), undefined, 32));
        case 'sha256':
            const sha256 = (0, crypto_1.createHash)('sha256');
            sha256.update(new TextEncoder().encode(message));
            return utils.binToHex(sha256.digest());
        case 'blake2b':
            return utils.binToHex(blakejs_1.default.blake2b(message, undefined, 32));
        case 'identity':
            return message;
        default:
            throw Error(`Invalid message hasher: ${hasher}`);
    }
}
exports.hashMessage = hashMessage;
function verifySignedMessage(message, messageHasher, publicKey, signature, keyType) {
    const messageHash = hashMessage(message, messageHasher);
    return utils.verifySignature(messageHash, publicKey, signature, keyType);
}
exports.verifySignedMessage = verifySignedMessage;
function toApiDestination(data) {
    return { ...data, attoAlphAmount: (0, api_1.toApiNumber256)(data.attoAlphAmount), tokens: (0, api_1.toApiTokens)(data.tokens) };
}
exports.toApiDestination = toApiDestination;
function toApiDestinations(data) {
    return data.map(toApiDestination);
}
exports.toApiDestinations = toApiDestinations;
function fromApiDestination(data) {
    return { ...data, attoAlphAmount: (0, api_1.fromApiNumber256)(data.attoAlphAmount), tokens: (0, api_1.fromApiTokens)(data.tokens) };
}
exports.fromApiDestination = fromApiDestination;
