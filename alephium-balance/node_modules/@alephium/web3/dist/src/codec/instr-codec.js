"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.I256Add = exports.BoolToByteVec = exports.BoolNeq = exports.BoolEq = exports.BoolOr = exports.BoolAnd = exports.BoolNot = exports.Pop = exports.StoreLocal = exports.LoadLocal = exports.AddressConst = exports.BytesConst = exports.U256Const = exports.I256Const = exports.U256Const5 = exports.U256Const4 = exports.U256Const3 = exports.U256Const2 = exports.U256Const1 = exports.U256Const0 = exports.I256ConstN1 = exports.I256Const5 = exports.I256Const4 = exports.I256Const3 = exports.I256Const2 = exports.I256Const1 = exports.I256Const0 = exports.ConstFalse = exports.ConstTrue = exports.Return = exports.CallExternal = exports.CallLocal = exports.CallExternalBySelectorCode = exports.MethodSelectorCode = exports.CreateMapEntryCode = exports.LoadImmFieldCode = exports.StoreMutFieldCode = exports.LoadMutFieldCode = exports.DEBUGCode = exports.IfFalseCode = exports.IfTrueCode = exports.JumpCode = exports.StoreLocalCode = exports.LoadLocalCode = exports.AddressConstCode = exports.BytesConstCode = exports.U256ConstCode = exports.I256ConstCode = exports.CallExternalCode = exports.CallLocalCode = void 0;
exports.Sha3 = exports.Sha256 = exports.Keccak256 = exports.Blake2b = exports.Assert = exports.IfFalse = exports.IfTrue = exports.Jump = exports.IsContractAddress = exports.IsAssetAddress = exports.AddressToByteVec = exports.AddressNeq = exports.AddressEq = exports.ByteVecConcat = exports.ByteVecSize = exports.ByteVecNeq = exports.ByteVecEq = exports.U256ToByteVec = exports.U256ToI256 = exports.I256ToByteVec = exports.I256ToU256 = exports.U256SHR = exports.U256SHL = exports.U256Xor = exports.U256BitOr = exports.U256BitAnd = exports.U256ModMul = exports.U256ModSub = exports.U256ModAdd = exports.U256Ge = exports.U256Gt = exports.U256Le = exports.U256Lt = exports.U256Neq = exports.U256Eq = exports.U256Mod = exports.U256Div = exports.U256Mul = exports.U256Sub = exports.U256Add = exports.I256Ge = exports.I256Gt = exports.I256Le = exports.I256Lt = exports.I256Neq = exports.I256Eq = exports.I256Mod = exports.I256Div = exports.I256Mul = exports.I256Sub = void 0;
exports.U256Exp = exports.I256Exp = exports.TxGasFee = exports.TxGasAmount = exports.TxGasPrice = exports.DEBUG = exports.BlockHash = exports.Swap = exports.AssertWithErrorCode = exports.Dup = exports.StoreLocalByIndex = exports.LoadLocalByIndex = exports.ContractIdToAddress = exports.Log9 = exports.Log8 = exports.Log7 = exports.Log6 = exports.EthEcRecover = exports.U256From32Byte = exports.U256From16Byte = exports.U256From8Byte = exports.U256From4Byte = exports.U256From2Byte = exports.U256From1Byte = exports.U256To32Byte = exports.U256To16Byte = exports.U256To8Byte = exports.U256To4Byte = exports.U256To2Byte = exports.U256To1Byte = exports.Zeros = exports.Encode = exports.ByteVecToAddress = exports.ByteVecSlice = exports.Log5 = exports.Log4 = exports.Log3 = exports.Log2 = exports.Log1 = exports.VerifyRelativeLocktime = exports.VerifyAbsoluteLocktime = exports.TxInputsSize = exports.TxInputAddressAt = exports.TxId = exports.BlockTarget = exports.BlockTimeStamp = exports.NetworkId = exports.VerifyED25519 = exports.VerifySecP256K1 = exports.VerifyTxSignature = void 0;
exports.CreateSubContractAndTransferToken = exports.CopyCreateContractAndTransferToken = exports.CreateContractAndTransferToken = exports.ContractExists = exports.StoreMutFieldByIndex = exports.LoadMutFieldByIndex = exports.CopyCreateSubContractWithToken = exports.CopyCreateSubContract = exports.CreateSubContractWithToken = exports.CreateSubContract = exports.LockApprovedAssets = exports.BurnToken = exports.CopyCreateContractWithToken = exports.MigrateWithFields = exports.MigrateSimple = exports.ContractCodeHash = exports.ContractInitialStateHash = exports.CallerCodeHash = exports.CallerInitialStateHash = exports.IsCalledFromTxScript = exports.CallerAddress = exports.CallerContractId = exports.SelfAddress = exports.SelfContractId = exports.DestroySelf = exports.CopyCreateContract = exports.CreateContractWithToken = exports.CreateContract = exports.TransferTokenToSelf = exports.TransferTokenFromSelf = exports.TransferToken = exports.TransferAlphToSelf = exports.TransferAlphFromSelf = exports.TransferAlph = exports.IsPaying = exports.TokenRemaining = exports.AlphRemaining = exports.ApproveToken = exports.ApproveAlph = exports.StoreMutField = exports.LoadMutField = exports.GroupOfAddress = exports.BoolToString = exports.I256ToString = exports.U256ToString = exports.AddModN = exports.MulModN = exports.GetSegregatedSignature = exports.VerifyBIP340Schnorr = exports.U256ModExp = void 0;
exports.toI256 = exports.toU256 = exports.instrsCodec = exports.instrCodec = exports.InstrCodec = exports.CallExternalBySelector = exports.MethodSelector = exports.CreateMapEntry = exports.MinimalContractDeposit = exports.PayGasFee = exports.LoadImmFieldByIndex = exports.LoadImmField = exports.ALPHTokenId = exports.SubContractIdOf = exports.SubContractId = exports.NullContractAddress = exports.CopyCreateSubContractAndTransferToken = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/
// auto-generated, do not edit
const array_codec_1 = require("./array-codec");
const compact_int_codec_1 = require("./compact-int-codec");
const bytestring_codec_1 = require("./bytestring-codec");
const lockup_script_codec_1 = require("./lockup-script-codec");
const codec_1 = require("./codec");
const int_as_4bytes_codec_1 = require("./int-as-4bytes-codec");
exports.CallLocalCode = 0x00;
exports.CallExternalCode = 0x01;
exports.I256ConstCode = 0x12;
exports.U256ConstCode = 0x13;
exports.BytesConstCode = 0x14;
exports.AddressConstCode = 0x15;
exports.LoadLocalCode = 0x16;
exports.StoreLocalCode = 0x17;
exports.JumpCode = 0x4a;
exports.IfTrueCode = 0x4b;
exports.IfFalseCode = 0x4c;
exports.DEBUGCode = 0x7e;
exports.LoadMutFieldCode = 0xa0;
exports.StoreMutFieldCode = 0xa1;
exports.LoadImmFieldCode = 0xce;
exports.CreateMapEntryCode = 0xd2;
exports.MethodSelectorCode = 0xd3;
exports.CallExternalBySelectorCode = 0xd4;
const CallLocal = (index) => {
    return { name: 'CallLocal', code: 0x00, index };
};
exports.CallLocal = CallLocal;
const CallExternal = (index) => {
    return { name: 'CallExternal', code: 0x01, index };
};
exports.CallExternal = CallExternal;
exports.Return = { name: 'Return', code: 0x02 };
exports.ConstTrue = { name: 'ConstTrue', code: 0x03 };
exports.ConstFalse = { name: 'ConstFalse', code: 0x04 };
exports.I256Const0 = { name: 'I256Const0', code: 0x05 };
exports.I256Const1 = { name: 'I256Const1', code: 0x06 };
exports.I256Const2 = { name: 'I256Const2', code: 0x07 };
exports.I256Const3 = { name: 'I256Const3', code: 0x08 };
exports.I256Const4 = { name: 'I256Const4', code: 0x09 };
exports.I256Const5 = { name: 'I256Const5', code: 0x0a };
exports.I256ConstN1 = { name: 'I256ConstN1', code: 0x0b };
exports.U256Const0 = { name: 'U256Const0', code: 0x0c };
exports.U256Const1 = { name: 'U256Const1', code: 0x0d };
exports.U256Const2 = { name: 'U256Const2', code: 0x0e };
exports.U256Const3 = { name: 'U256Const3', code: 0x0f };
exports.U256Const4 = { name: 'U256Const4', code: 0x10 };
exports.U256Const5 = { name: 'U256Const5', code: 0x11 };
const I256Const = (value) => {
    return { name: 'I256Const', code: 0x12, value };
};
exports.I256Const = I256Const;
const U256Const = (value) => {
    return { name: 'U256Const', code: 0x13, value };
};
exports.U256Const = U256Const;
const BytesConst = (value) => {
    return { name: 'BytesConst', code: 0x14, value };
};
exports.BytesConst = BytesConst;
const AddressConst = (value) => {
    return { name: 'AddressConst', code: 0x15, value };
};
exports.AddressConst = AddressConst;
const LoadLocal = (index) => {
    return { name: 'LoadLocal', code: 0x16, index };
};
exports.LoadLocal = LoadLocal;
const StoreLocal = (index) => {
    return { name: 'StoreLocal', code: 0x17, index };
};
exports.StoreLocal = StoreLocal;
exports.Pop = { name: 'Pop', code: 0x18 };
exports.BoolNot = { name: 'BoolNot', code: 0x19 };
exports.BoolAnd = { name: 'BoolAnd', code: 0x1a };
exports.BoolOr = { name: 'BoolOr', code: 0x1b };
exports.BoolEq = { name: 'BoolEq', code: 0x1c };
exports.BoolNeq = { name: 'BoolNeq', code: 0x1d };
exports.BoolToByteVec = { name: 'BoolToByteVec', code: 0x1e };
exports.I256Add = { name: 'I256Add', code: 0x1f };
exports.I256Sub = { name: 'I256Sub', code: 0x20 };
exports.I256Mul = { name: 'I256Mul', code: 0x21 };
exports.I256Div = { name: 'I256Div', code: 0x22 };
exports.I256Mod = { name: 'I256Mod', code: 0x23 };
exports.I256Eq = { name: 'I256Eq', code: 0x24 };
exports.I256Neq = { name: 'I256Neq', code: 0x25 };
exports.I256Lt = { name: 'I256Lt', code: 0x26 };
exports.I256Le = { name: 'I256Le', code: 0x27 };
exports.I256Gt = { name: 'I256Gt', code: 0x28 };
exports.I256Ge = { name: 'I256Ge', code: 0x29 };
exports.U256Add = { name: 'U256Add', code: 0x2a };
exports.U256Sub = { name: 'U256Sub', code: 0x2b };
exports.U256Mul = { name: 'U256Mul', code: 0x2c };
exports.U256Div = { name: 'U256Div', code: 0x2d };
exports.U256Mod = { name: 'U256Mod', code: 0x2e };
exports.U256Eq = { name: 'U256Eq', code: 0x2f };
exports.U256Neq = { name: 'U256Neq', code: 0x30 };
exports.U256Lt = { name: 'U256Lt', code: 0x31 };
exports.U256Le = { name: 'U256Le', code: 0x32 };
exports.U256Gt = { name: 'U256Gt', code: 0x33 };
exports.U256Ge = { name: 'U256Ge', code: 0x34 };
exports.U256ModAdd = { name: 'U256ModAdd', code: 0x35 };
exports.U256ModSub = { name: 'U256ModSub', code: 0x36 };
exports.U256ModMul = { name: 'U256ModMul', code: 0x37 };
exports.U256BitAnd = { name: 'U256BitAnd', code: 0x38 };
exports.U256BitOr = { name: 'U256BitOr', code: 0x39 };
exports.U256Xor = { name: 'U256Xor', code: 0x3a };
exports.U256SHL = { name: 'U256SHL', code: 0x3b };
exports.U256SHR = { name: 'U256SHR', code: 0x3c };
exports.I256ToU256 = { name: 'I256ToU256', code: 0x3d };
exports.I256ToByteVec = { name: 'I256ToByteVec', code: 0x3e };
exports.U256ToI256 = { name: 'U256ToI256', code: 0x3f };
exports.U256ToByteVec = { name: 'U256ToByteVec', code: 0x40 };
exports.ByteVecEq = { name: 'ByteVecEq', code: 0x41 };
exports.ByteVecNeq = { name: 'ByteVecNeq', code: 0x42 };
exports.ByteVecSize = { name: 'ByteVecSize', code: 0x43 };
exports.ByteVecConcat = { name: 'ByteVecConcat', code: 0x44 };
exports.AddressEq = { name: 'AddressEq', code: 0x45 };
exports.AddressNeq = { name: 'AddressNeq', code: 0x46 };
exports.AddressToByteVec = { name: 'AddressToByteVec', code: 0x47 };
exports.IsAssetAddress = { name: 'IsAssetAddress', code: 0x48 };
exports.IsContractAddress = { name: 'IsContractAddress', code: 0x49 };
const Jump = (offset) => {
    return { name: 'Jump', code: 0x4a, offset };
};
exports.Jump = Jump;
const IfTrue = (offset) => {
    return { name: 'IfTrue', code: 0x4b, offset };
};
exports.IfTrue = IfTrue;
const IfFalse = (offset) => {
    return { name: 'IfFalse', code: 0x4c, offset };
};
exports.IfFalse = IfFalse;
exports.Assert = { name: 'Assert', code: 0x4d };
exports.Blake2b = { name: 'Blake2b', code: 0x4e };
exports.Keccak256 = { name: 'Keccak256', code: 0x4f };
exports.Sha256 = { name: 'Sha256', code: 0x50 };
exports.Sha3 = { name: 'Sha3', code: 0x51 };
exports.VerifyTxSignature = { name: 'VerifyTxSignature', code: 0x52 };
exports.VerifySecP256K1 = { name: 'VerifySecP256K1', code: 0x53 };
exports.VerifyED25519 = { name: 'VerifyED25519', code: 0x54 };
exports.NetworkId = { name: 'NetworkId', code: 0x55 };
exports.BlockTimeStamp = { name: 'BlockTimeStamp', code: 0x56 };
exports.BlockTarget = { name: 'BlockTarget', code: 0x57 };
exports.TxId = { name: 'TxId', code: 0x58 };
exports.TxInputAddressAt = { name: 'TxInputAddressAt', code: 0x59 };
exports.TxInputsSize = { name: 'TxInputsSize', code: 0x5a };
exports.VerifyAbsoluteLocktime = { name: 'VerifyAbsoluteLocktime', code: 0x5b };
exports.VerifyRelativeLocktime = { name: 'VerifyRelativeLocktime', code: 0x5c };
exports.Log1 = { name: 'Log1', code: 0x5d };
exports.Log2 = { name: 'Log2', code: 0x5e };
exports.Log3 = { name: 'Log3', code: 0x5f };
exports.Log4 = { name: 'Log4', code: 0x60 };
exports.Log5 = { name: 'Log5', code: 0x61 };
exports.ByteVecSlice = { name: 'ByteVecSlice', code: 0x62 };
exports.ByteVecToAddress = { name: 'ByteVecToAddress', code: 0x63 };
exports.Encode = { name: 'Encode', code: 0x64 };
exports.Zeros = { name: 'Zeros', code: 0x65 };
exports.U256To1Byte = { name: 'U256To1Byte', code: 0x66 };
exports.U256To2Byte = { name: 'U256To2Byte', code: 0x67 };
exports.U256To4Byte = { name: 'U256To4Byte', code: 0x68 };
exports.U256To8Byte = { name: 'U256To8Byte', code: 0x69 };
exports.U256To16Byte = { name: 'U256To16Byte', code: 0x6a };
exports.U256To32Byte = { name: 'U256To32Byte', code: 0x6b };
exports.U256From1Byte = { name: 'U256From1Byte', code: 0x6c };
exports.U256From2Byte = { name: 'U256From2Byte', code: 0x6d };
exports.U256From4Byte = { name: 'U256From4Byte', code: 0x6e };
exports.U256From8Byte = { name: 'U256From8Byte', code: 0x6f };
exports.U256From16Byte = { name: 'U256From16Byte', code: 0x70 };
exports.U256From32Byte = { name: 'U256From32Byte', code: 0x71 };
exports.EthEcRecover = { name: 'EthEcRecover', code: 0x72 };
exports.Log6 = { name: 'Log6', code: 0x73 };
exports.Log7 = { name: 'Log7', code: 0x74 };
exports.Log8 = { name: 'Log8', code: 0x75 };
exports.Log9 = { name: 'Log9', code: 0x76 };
exports.ContractIdToAddress = { name: 'ContractIdToAddress', code: 0x77 };
exports.LoadLocalByIndex = { name: 'LoadLocalByIndex', code: 0x78 };
exports.StoreLocalByIndex = { name: 'StoreLocalByIndex', code: 0x79 };
exports.Dup = { name: 'Dup', code: 0x7a };
exports.AssertWithErrorCode = { name: 'AssertWithErrorCode', code: 0x7b };
exports.Swap = { name: 'Swap', code: 0x7c };
exports.BlockHash = { name: 'BlockHash', code: 0x7d };
const DEBUG = (stringParts) => {
    return { name: 'DEBUG', code: 0x7e, stringParts };
};
exports.DEBUG = DEBUG;
exports.TxGasPrice = { name: 'TxGasPrice', code: 0x7f };
exports.TxGasAmount = { name: 'TxGasAmount', code: 0x80 };
exports.TxGasFee = { name: 'TxGasFee', code: 0x81 };
exports.I256Exp = { name: 'I256Exp', code: 0x82 };
exports.U256Exp = { name: 'U256Exp', code: 0x83 };
exports.U256ModExp = { name: 'U256ModExp', code: 0x84 };
exports.VerifyBIP340Schnorr = { name: 'VerifyBIP340Schnorr', code: 0x85 };
exports.GetSegregatedSignature = { name: 'GetSegregatedSignature', code: 0x86 };
exports.MulModN = { name: 'MulModN', code: 0x87 };
exports.AddModN = { name: 'AddModN', code: 0x88 };
exports.U256ToString = { name: 'U256ToString', code: 0x89 };
exports.I256ToString = { name: 'I256ToString', code: 0x8a };
exports.BoolToString = { name: 'BoolToString', code: 0x8b };
exports.GroupOfAddress = { name: 'GroupOfAddress', code: 0x8c };
const LoadMutField = (index) => {
    return { name: 'LoadMutField', code: 0xa0, index };
};
exports.LoadMutField = LoadMutField;
const StoreMutField = (index) => {
    return { name: 'StoreMutField', code: 0xa1, index };
};
exports.StoreMutField = StoreMutField;
exports.ApproveAlph = { name: 'ApproveAlph', code: 0xa2 };
exports.ApproveToken = { name: 'ApproveToken', code: 0xa3 };
exports.AlphRemaining = { name: 'AlphRemaining', code: 0xa4 };
exports.TokenRemaining = { name: 'TokenRemaining', code: 0xa5 };
exports.IsPaying = { name: 'IsPaying', code: 0xa6 };
exports.TransferAlph = { name: 'TransferAlph', code: 0xa7 };
exports.TransferAlphFromSelf = { name: 'TransferAlphFromSelf', code: 0xa8 };
exports.TransferAlphToSelf = { name: 'TransferAlphToSelf', code: 0xa9 };
exports.TransferToken = { name: 'TransferToken', code: 0xaa };
exports.TransferTokenFromSelf = { name: 'TransferTokenFromSelf', code: 0xab };
exports.TransferTokenToSelf = { name: 'TransferTokenToSelf', code: 0xac };
exports.CreateContract = { name: 'CreateContract', code: 0xad };
exports.CreateContractWithToken = { name: 'CreateContractWithToken', code: 0xae };
exports.CopyCreateContract = { name: 'CopyCreateContract', code: 0xaf };
exports.DestroySelf = { name: 'DestroySelf', code: 0xb0 };
exports.SelfContractId = { name: 'SelfContractId', code: 0xb1 };
exports.SelfAddress = { name: 'SelfAddress', code: 0xb2 };
exports.CallerContractId = { name: 'CallerContractId', code: 0xb3 };
exports.CallerAddress = { name: 'CallerAddress', code: 0xb4 };
exports.IsCalledFromTxScript = { name: 'IsCalledFromTxScript', code: 0xb5 };
exports.CallerInitialStateHash = { name: 'CallerInitialStateHash', code: 0xb6 };
exports.CallerCodeHash = { name: 'CallerCodeHash', code: 0xb7 };
exports.ContractInitialStateHash = { name: 'ContractInitialStateHash', code: 0xb8 };
exports.ContractCodeHash = { name: 'ContractCodeHash', code: 0xb9 };
exports.MigrateSimple = { name: 'MigrateSimple', code: 0xba };
exports.MigrateWithFields = { name: 'MigrateWithFields', code: 0xbb };
exports.CopyCreateContractWithToken = { name: 'CopyCreateContractWithToken', code: 0xbc };
exports.BurnToken = { name: 'BurnToken', code: 0xbd };
exports.LockApprovedAssets = { name: 'LockApprovedAssets', code: 0xbe };
exports.CreateSubContract = { name: 'CreateSubContract', code: 0xbf };
exports.CreateSubContractWithToken = { name: 'CreateSubContractWithToken', code: 0xc0 };
exports.CopyCreateSubContract = { name: 'CopyCreateSubContract', code: 0xc1 };
exports.CopyCreateSubContractWithToken = { name: 'CopyCreateSubContractWithToken', code: 0xc2 };
exports.LoadMutFieldByIndex = { name: 'LoadMutFieldByIndex', code: 0xc3 };
exports.StoreMutFieldByIndex = { name: 'StoreMutFieldByIndex', code: 0xc4 };
exports.ContractExists = { name: 'ContractExists', code: 0xc5 };
exports.CreateContractAndTransferToken = { name: 'CreateContractAndTransferToken', code: 0xc6 };
exports.CopyCreateContractAndTransferToken = { name: 'CopyCreateContractAndTransferToken', code: 0xc7 };
exports.CreateSubContractAndTransferToken = { name: 'CreateSubContractAndTransferToken', code: 0xc8 };
exports.CopyCreateSubContractAndTransferToken = {
    name: 'CopyCreateSubContractAndTransferToken',
    code: 0xc9
};
exports.NullContractAddress = { name: 'NullContractAddress', code: 0xca };
exports.SubContractId = { name: 'SubContractId', code: 0xcb };
exports.SubContractIdOf = { name: 'SubContractIdOf', code: 0xcc };
exports.ALPHTokenId = { name: 'ALPHTokenId', code: 0xcd };
const LoadImmField = (index) => {
    return { name: 'LoadImmField', code: 0xce, index };
};
exports.LoadImmField = LoadImmField;
exports.LoadImmFieldByIndex = { name: 'LoadImmFieldByIndex', code: 0xcf };
exports.PayGasFee = { name: 'PayGasFee', code: 0xd0 };
exports.MinimalContractDeposit = { name: 'MinimalContractDeposit', code: 0xd1 };
const CreateMapEntry = (immFieldsNum, mutFieldsNum) => {
    return { name: 'CreateMapEntry', code: 0xd2, immFieldsNum, mutFieldsNum };
};
exports.CreateMapEntry = CreateMapEntry;
const MethodSelector = (selector) => {
    return { name: 'MethodSelector', code: 0xd3, selector };
};
exports.MethodSelector = MethodSelector;
const CallExternalBySelector = (selector) => {
    return { name: 'CallExternalBySelector', code: 0xd4, selector };
};
exports.CallExternalBySelector = CallExternalBySelector;
class InstrCodec extends codec_1.Codec {
    encode(instr) {
        switch (instr.name) {
            case 'CallLocal':
                return new Uint8Array([0x00, ...codec_1.byteCodec.encode(instr.index)]);
            case 'CallExternal':
                return new Uint8Array([0x01, ...codec_1.byteCodec.encode(instr.index)]);
            case 'Return':
                return new Uint8Array([0x02]);
            case 'ConstTrue':
                return new Uint8Array([0x03]);
            case 'ConstFalse':
                return new Uint8Array([0x04]);
            case 'I256Const0':
                return new Uint8Array([0x05]);
            case 'I256Const1':
                return new Uint8Array([0x06]);
            case 'I256Const2':
                return new Uint8Array([0x07]);
            case 'I256Const3':
                return new Uint8Array([0x08]);
            case 'I256Const4':
                return new Uint8Array([0x09]);
            case 'I256Const5':
                return new Uint8Array([0x0a]);
            case 'I256ConstN1':
                return new Uint8Array([0x0b]);
            case 'U256Const0':
                return new Uint8Array([0x0c]);
            case 'U256Const1':
                return new Uint8Array([0x0d]);
            case 'U256Const2':
                return new Uint8Array([0x0e]);
            case 'U256Const3':
                return new Uint8Array([0x0f]);
            case 'U256Const4':
                return new Uint8Array([0x10]);
            case 'U256Const5':
                return new Uint8Array([0x11]);
            case 'I256Const':
                return new Uint8Array([0x12, ...compact_int_codec_1.i256Codec.encode(instr.value)]);
            case 'U256Const':
                return new Uint8Array([0x13, ...compact_int_codec_1.u256Codec.encode(instr.value)]);
            case 'BytesConst':
                return new Uint8Array([0x14, ...bytestring_codec_1.byteStringCodec.encode(instr.value)]);
            case 'AddressConst':
                return new Uint8Array([0x15, ...lockup_script_codec_1.lockupScriptCodec.encode(instr.value)]);
            case 'LoadLocal':
                return new Uint8Array([0x16, ...codec_1.byteCodec.encode(instr.index)]);
            case 'StoreLocal':
                return new Uint8Array([0x17, ...codec_1.byteCodec.encode(instr.index)]);
            case 'Pop':
                return new Uint8Array([0x18]);
            case 'BoolNot':
                return new Uint8Array([0x19]);
            case 'BoolAnd':
                return new Uint8Array([0x1a]);
            case 'BoolOr':
                return new Uint8Array([0x1b]);
            case 'BoolEq':
                return new Uint8Array([0x1c]);
            case 'BoolNeq':
                return new Uint8Array([0x1d]);
            case 'BoolToByteVec':
                return new Uint8Array([0x1e]);
            case 'I256Add':
                return new Uint8Array([0x1f]);
            case 'I256Sub':
                return new Uint8Array([0x20]);
            case 'I256Mul':
                return new Uint8Array([0x21]);
            case 'I256Div':
                return new Uint8Array([0x22]);
            case 'I256Mod':
                return new Uint8Array([0x23]);
            case 'I256Eq':
                return new Uint8Array([0x24]);
            case 'I256Neq':
                return new Uint8Array([0x25]);
            case 'I256Lt':
                return new Uint8Array([0x26]);
            case 'I256Le':
                return new Uint8Array([0x27]);
            case 'I256Gt':
                return new Uint8Array([0x28]);
            case 'I256Ge':
                return new Uint8Array([0x29]);
            case 'U256Add':
                return new Uint8Array([0x2a]);
            case 'U256Sub':
                return new Uint8Array([0x2b]);
            case 'U256Mul':
                return new Uint8Array([0x2c]);
            case 'U256Div':
                return new Uint8Array([0x2d]);
            case 'U256Mod':
                return new Uint8Array([0x2e]);
            case 'U256Eq':
                return new Uint8Array([0x2f]);
            case 'U256Neq':
                return new Uint8Array([0x30]);
            case 'U256Lt':
                return new Uint8Array([0x31]);
            case 'U256Le':
                return new Uint8Array([0x32]);
            case 'U256Gt':
                return new Uint8Array([0x33]);
            case 'U256Ge':
                return new Uint8Array([0x34]);
            case 'U256ModAdd':
                return new Uint8Array([0x35]);
            case 'U256ModSub':
                return new Uint8Array([0x36]);
            case 'U256ModMul':
                return new Uint8Array([0x37]);
            case 'U256BitAnd':
                return new Uint8Array([0x38]);
            case 'U256BitOr':
                return new Uint8Array([0x39]);
            case 'U256Xor':
                return new Uint8Array([0x3a]);
            case 'U256SHL':
                return new Uint8Array([0x3b]);
            case 'U256SHR':
                return new Uint8Array([0x3c]);
            case 'I256ToU256':
                return new Uint8Array([0x3d]);
            case 'I256ToByteVec':
                return new Uint8Array([0x3e]);
            case 'U256ToI256':
                return new Uint8Array([0x3f]);
            case 'U256ToByteVec':
                return new Uint8Array([0x40]);
            case 'ByteVecEq':
                return new Uint8Array([0x41]);
            case 'ByteVecNeq':
                return new Uint8Array([0x42]);
            case 'ByteVecSize':
                return new Uint8Array([0x43]);
            case 'ByteVecConcat':
                return new Uint8Array([0x44]);
            case 'AddressEq':
                return new Uint8Array([0x45]);
            case 'AddressNeq':
                return new Uint8Array([0x46]);
            case 'AddressToByteVec':
                return new Uint8Array([0x47]);
            case 'IsAssetAddress':
                return new Uint8Array([0x48]);
            case 'IsContractAddress':
                return new Uint8Array([0x49]);
            case 'Jump':
                return new Uint8Array([0x4a, ...compact_int_codec_1.i32Codec.encode(instr.offset)]);
            case 'IfTrue':
                return new Uint8Array([0x4b, ...compact_int_codec_1.i32Codec.encode(instr.offset)]);
            case 'IfFalse':
                return new Uint8Array([0x4c, ...compact_int_codec_1.i32Codec.encode(instr.offset)]);
            case 'Assert':
                return new Uint8Array([0x4d]);
            case 'Blake2b':
                return new Uint8Array([0x4e]);
            case 'Keccak256':
                return new Uint8Array([0x4f]);
            case 'Sha256':
                return new Uint8Array([0x50]);
            case 'Sha3':
                return new Uint8Array([0x51]);
            case 'VerifyTxSignature':
                return new Uint8Array([0x52]);
            case 'VerifySecP256K1':
                return new Uint8Array([0x53]);
            case 'VerifyED25519':
                return new Uint8Array([0x54]);
            case 'NetworkId':
                return new Uint8Array([0x55]);
            case 'BlockTimeStamp':
                return new Uint8Array([0x56]);
            case 'BlockTarget':
                return new Uint8Array([0x57]);
            case 'TxId':
                return new Uint8Array([0x58]);
            case 'TxInputAddressAt':
                return new Uint8Array([0x59]);
            case 'TxInputsSize':
                return new Uint8Array([0x5a]);
            case 'VerifyAbsoluteLocktime':
                return new Uint8Array([0x5b]);
            case 'VerifyRelativeLocktime':
                return new Uint8Array([0x5c]);
            case 'Log1':
                return new Uint8Array([0x5d]);
            case 'Log2':
                return new Uint8Array([0x5e]);
            case 'Log3':
                return new Uint8Array([0x5f]);
            case 'Log4':
                return new Uint8Array([0x60]);
            case 'Log5':
                return new Uint8Array([0x61]);
            case 'ByteVecSlice':
                return new Uint8Array([0x62]);
            case 'ByteVecToAddress':
                return new Uint8Array([0x63]);
            case 'Encode':
                return new Uint8Array([0x64]);
            case 'Zeros':
                return new Uint8Array([0x65]);
            case 'U256To1Byte':
                return new Uint8Array([0x66]);
            case 'U256To2Byte':
                return new Uint8Array([0x67]);
            case 'U256To4Byte':
                return new Uint8Array([0x68]);
            case 'U256To8Byte':
                return new Uint8Array([0x69]);
            case 'U256To16Byte':
                return new Uint8Array([0x6a]);
            case 'U256To32Byte':
                return new Uint8Array([0x6b]);
            case 'U256From1Byte':
                return new Uint8Array([0x6c]);
            case 'U256From2Byte':
                return new Uint8Array([0x6d]);
            case 'U256From4Byte':
                return new Uint8Array([0x6e]);
            case 'U256From8Byte':
                return new Uint8Array([0x6f]);
            case 'U256From16Byte':
                return new Uint8Array([0x70]);
            case 'U256From32Byte':
                return new Uint8Array([0x71]);
            case 'EthEcRecover':
                return new Uint8Array([0x72]);
            case 'Log6':
                return new Uint8Array([0x73]);
            case 'Log7':
                return new Uint8Array([0x74]);
            case 'Log8':
                return new Uint8Array([0x75]);
            case 'Log9':
                return new Uint8Array([0x76]);
            case 'ContractIdToAddress':
                return new Uint8Array([0x77]);
            case 'LoadLocalByIndex':
                return new Uint8Array([0x78]);
            case 'StoreLocalByIndex':
                return new Uint8Array([0x79]);
            case 'Dup':
                return new Uint8Array([0x7a]);
            case 'AssertWithErrorCode':
                return new Uint8Array([0x7b]);
            case 'Swap':
                return new Uint8Array([0x7c]);
            case 'BlockHash':
                return new Uint8Array([0x7d]);
            case 'DEBUG':
                return new Uint8Array([0x7e, ...bytestring_codec_1.byteStringsCodec.encode(instr.stringParts)]);
            case 'TxGasPrice':
                return new Uint8Array([0x7f]);
            case 'TxGasAmount':
                return new Uint8Array([0x80]);
            case 'TxGasFee':
                return new Uint8Array([0x81]);
            case 'I256Exp':
                return new Uint8Array([0x82]);
            case 'U256Exp':
                return new Uint8Array([0x83]);
            case 'U256ModExp':
                return new Uint8Array([0x84]);
            case 'VerifyBIP340Schnorr':
                return new Uint8Array([0x85]);
            case 'GetSegregatedSignature':
                return new Uint8Array([0x86]);
            case 'MulModN':
                return new Uint8Array([0x87]);
            case 'AddModN':
                return new Uint8Array([0x88]);
            case 'U256ToString':
                return new Uint8Array([0x89]);
            case 'I256ToString':
                return new Uint8Array([0x8a]);
            case 'BoolToString':
                return new Uint8Array([0x8b]);
            case 'GroupOfAddress':
                return new Uint8Array([0x8c]);
            case 'LoadMutField':
                return new Uint8Array([0xa0, ...codec_1.byteCodec.encode(instr.index)]);
            case 'StoreMutField':
                return new Uint8Array([0xa1, ...codec_1.byteCodec.encode(instr.index)]);
            case 'ApproveAlph':
                return new Uint8Array([0xa2]);
            case 'ApproveToken':
                return new Uint8Array([0xa3]);
            case 'AlphRemaining':
                return new Uint8Array([0xa4]);
            case 'TokenRemaining':
                return new Uint8Array([0xa5]);
            case 'IsPaying':
                return new Uint8Array([0xa6]);
            case 'TransferAlph':
                return new Uint8Array([0xa7]);
            case 'TransferAlphFromSelf':
                return new Uint8Array([0xa8]);
            case 'TransferAlphToSelf':
                return new Uint8Array([0xa9]);
            case 'TransferToken':
                return new Uint8Array([0xaa]);
            case 'TransferTokenFromSelf':
                return new Uint8Array([0xab]);
            case 'TransferTokenToSelf':
                return new Uint8Array([0xac]);
            case 'CreateContract':
                return new Uint8Array([0xad]);
            case 'CreateContractWithToken':
                return new Uint8Array([0xae]);
            case 'CopyCreateContract':
                return new Uint8Array([0xaf]);
            case 'DestroySelf':
                return new Uint8Array([0xb0]);
            case 'SelfContractId':
                return new Uint8Array([0xb1]);
            case 'SelfAddress':
                return new Uint8Array([0xb2]);
            case 'CallerContractId':
                return new Uint8Array([0xb3]);
            case 'CallerAddress':
                return new Uint8Array([0xb4]);
            case 'IsCalledFromTxScript':
                return new Uint8Array([0xb5]);
            case 'CallerInitialStateHash':
                return new Uint8Array([0xb6]);
            case 'CallerCodeHash':
                return new Uint8Array([0xb7]);
            case 'ContractInitialStateHash':
                return new Uint8Array([0xb8]);
            case 'ContractCodeHash':
                return new Uint8Array([0xb9]);
            case 'MigrateSimple':
                return new Uint8Array([0xba]);
            case 'MigrateWithFields':
                return new Uint8Array([0xbb]);
            case 'CopyCreateContractWithToken':
                return new Uint8Array([0xbc]);
            case 'BurnToken':
                return new Uint8Array([0xbd]);
            case 'LockApprovedAssets':
                return new Uint8Array([0xbe]);
            case 'CreateSubContract':
                return new Uint8Array([0xbf]);
            case 'CreateSubContractWithToken':
                return new Uint8Array([0xc0]);
            case 'CopyCreateSubContract':
                return new Uint8Array([0xc1]);
            case 'CopyCreateSubContractWithToken':
                return new Uint8Array([0xc2]);
            case 'LoadMutFieldByIndex':
                return new Uint8Array([0xc3]);
            case 'StoreMutFieldByIndex':
                return new Uint8Array([0xc4]);
            case 'ContractExists':
                return new Uint8Array([0xc5]);
            case 'CreateContractAndTransferToken':
                return new Uint8Array([0xc6]);
            case 'CopyCreateContractAndTransferToken':
                return new Uint8Array([0xc7]);
            case 'CreateSubContractAndTransferToken':
                return new Uint8Array([0xc8]);
            case 'CopyCreateSubContractAndTransferToken':
                return new Uint8Array([0xc9]);
            case 'NullContractAddress':
                return new Uint8Array([0xca]);
            case 'SubContractId':
                return new Uint8Array([0xcb]);
            case 'SubContractIdOf':
                return new Uint8Array([0xcc]);
            case 'ALPHTokenId':
                return new Uint8Array([0xcd]);
            case 'LoadImmField':
                return new Uint8Array([0xce, ...codec_1.byteCodec.encode(instr.index)]);
            case 'LoadImmFieldByIndex':
                return new Uint8Array([0xcf]);
            case 'PayGasFee':
                return new Uint8Array([0xd0]);
            case 'MinimalContractDeposit':
                return new Uint8Array([0xd1]);
            case 'CreateMapEntry':
                return new Uint8Array([0xd2, ...codec_1.byteCodec.encode(instr.immFieldsNum), ...codec_1.byteCodec.encode(instr.mutFieldsNum)]);
            case 'MethodSelector':
                return new Uint8Array([0xd3, ...int_as_4bytes_codec_1.intAs4BytesCodec.encode(instr.selector)]);
            case 'CallExternalBySelector':
                return new Uint8Array([0xd4, ...int_as_4bytes_codec_1.intAs4BytesCodec.encode(instr.selector)]);
        }
    }
    _decode(input) {
        const code = input.consumeByte();
        switch (code) {
            case 0x00:
                return (0, exports.CallLocal)(codec_1.byteCodec._decode(input));
            case 0x01:
                return (0, exports.CallExternal)(codec_1.byteCodec._decode(input));
            case 0x02:
                return exports.Return;
            case 0x03:
                return exports.ConstTrue;
            case 0x04:
                return exports.ConstFalse;
            case 0x05:
                return exports.I256Const0;
            case 0x06:
                return exports.I256Const1;
            case 0x07:
                return exports.I256Const2;
            case 0x08:
                return exports.I256Const3;
            case 0x09:
                return exports.I256Const4;
            case 0x0a:
                return exports.I256Const5;
            case 0x0b:
                return exports.I256ConstN1;
            case 0x0c:
                return exports.U256Const0;
            case 0x0d:
                return exports.U256Const1;
            case 0x0e:
                return exports.U256Const2;
            case 0x0f:
                return exports.U256Const3;
            case 0x10:
                return exports.U256Const4;
            case 0x11:
                return exports.U256Const5;
            case 0x12:
                return (0, exports.I256Const)(compact_int_codec_1.i256Codec._decode(input));
            case 0x13:
                return (0, exports.U256Const)(compact_int_codec_1.u256Codec._decode(input));
            case 0x14:
                return (0, exports.BytesConst)(bytestring_codec_1.byteStringCodec._decode(input));
            case 0x15:
                return (0, exports.AddressConst)(lockup_script_codec_1.lockupScriptCodec._decode(input));
            case 0x16:
                return (0, exports.LoadLocal)(codec_1.byteCodec._decode(input));
            case 0x17:
                return (0, exports.StoreLocal)(codec_1.byteCodec._decode(input));
            case 0x18:
                return exports.Pop;
            case 0x19:
                return exports.BoolNot;
            case 0x1a:
                return exports.BoolAnd;
            case 0x1b:
                return exports.BoolOr;
            case 0x1c:
                return exports.BoolEq;
            case 0x1d:
                return exports.BoolNeq;
            case 0x1e:
                return exports.BoolToByteVec;
            case 0x1f:
                return exports.I256Add;
            case 0x20:
                return exports.I256Sub;
            case 0x21:
                return exports.I256Mul;
            case 0x22:
                return exports.I256Div;
            case 0x23:
                return exports.I256Mod;
            case 0x24:
                return exports.I256Eq;
            case 0x25:
                return exports.I256Neq;
            case 0x26:
                return exports.I256Lt;
            case 0x27:
                return exports.I256Le;
            case 0x28:
                return exports.I256Gt;
            case 0x29:
                return exports.I256Ge;
            case 0x2a:
                return exports.U256Add;
            case 0x2b:
                return exports.U256Sub;
            case 0x2c:
                return exports.U256Mul;
            case 0x2d:
                return exports.U256Div;
            case 0x2e:
                return exports.U256Mod;
            case 0x2f:
                return exports.U256Eq;
            case 0x30:
                return exports.U256Neq;
            case 0x31:
                return exports.U256Lt;
            case 0x32:
                return exports.U256Le;
            case 0x33:
                return exports.U256Gt;
            case 0x34:
                return exports.U256Ge;
            case 0x35:
                return exports.U256ModAdd;
            case 0x36:
                return exports.U256ModSub;
            case 0x37:
                return exports.U256ModMul;
            case 0x38:
                return exports.U256BitAnd;
            case 0x39:
                return exports.U256BitOr;
            case 0x3a:
                return exports.U256Xor;
            case 0x3b:
                return exports.U256SHL;
            case 0x3c:
                return exports.U256SHR;
            case 0x3d:
                return exports.I256ToU256;
            case 0x3e:
                return exports.I256ToByteVec;
            case 0x3f:
                return exports.U256ToI256;
            case 0x40:
                return exports.U256ToByteVec;
            case 0x41:
                return exports.ByteVecEq;
            case 0x42:
                return exports.ByteVecNeq;
            case 0x43:
                return exports.ByteVecSize;
            case 0x44:
                return exports.ByteVecConcat;
            case 0x45:
                return exports.AddressEq;
            case 0x46:
                return exports.AddressNeq;
            case 0x47:
                return exports.AddressToByteVec;
            case 0x48:
                return exports.IsAssetAddress;
            case 0x49:
                return exports.IsContractAddress;
            case 0x4a:
                return (0, exports.Jump)(compact_int_codec_1.i32Codec._decode(input));
            case 0x4b:
                return (0, exports.IfTrue)(compact_int_codec_1.i32Codec._decode(input));
            case 0x4c:
                return (0, exports.IfFalse)(compact_int_codec_1.i32Codec._decode(input));
            case 0x4d:
                return exports.Assert;
            case 0x4e:
                return exports.Blake2b;
            case 0x4f:
                return exports.Keccak256;
            case 0x50:
                return exports.Sha256;
            case 0x51:
                return exports.Sha3;
            case 0x52:
                return exports.VerifyTxSignature;
            case 0x53:
                return exports.VerifySecP256K1;
            case 0x54:
                return exports.VerifyED25519;
            case 0x55:
                return exports.NetworkId;
            case 0x56:
                return exports.BlockTimeStamp;
            case 0x57:
                return exports.BlockTarget;
            case 0x58:
                return exports.TxId;
            case 0x59:
                return exports.TxInputAddressAt;
            case 0x5a:
                return exports.TxInputsSize;
            case 0x5b:
                return exports.VerifyAbsoluteLocktime;
            case 0x5c:
                return exports.VerifyRelativeLocktime;
            case 0x5d:
                return exports.Log1;
            case 0x5e:
                return exports.Log2;
            case 0x5f:
                return exports.Log3;
            case 0x60:
                return exports.Log4;
            case 0x61:
                return exports.Log5;
            case 0x62:
                return exports.ByteVecSlice;
            case 0x63:
                return exports.ByteVecToAddress;
            case 0x64:
                return exports.Encode;
            case 0x65:
                return exports.Zeros;
            case 0x66:
                return exports.U256To1Byte;
            case 0x67:
                return exports.U256To2Byte;
            case 0x68:
                return exports.U256To4Byte;
            case 0x69:
                return exports.U256To8Byte;
            case 0x6a:
                return exports.U256To16Byte;
            case 0x6b:
                return exports.U256To32Byte;
            case 0x6c:
                return exports.U256From1Byte;
            case 0x6d:
                return exports.U256From2Byte;
            case 0x6e:
                return exports.U256From4Byte;
            case 0x6f:
                return exports.U256From8Byte;
            case 0x70:
                return exports.U256From16Byte;
            case 0x71:
                return exports.U256From32Byte;
            case 0x72:
                return exports.EthEcRecover;
            case 0x73:
                return exports.Log6;
            case 0x74:
                return exports.Log7;
            case 0x75:
                return exports.Log8;
            case 0x76:
                return exports.Log9;
            case 0x77:
                return exports.ContractIdToAddress;
            case 0x78:
                return exports.LoadLocalByIndex;
            case 0x79:
                return exports.StoreLocalByIndex;
            case 0x7a:
                return exports.Dup;
            case 0x7b:
                return exports.AssertWithErrorCode;
            case 0x7c:
                return exports.Swap;
            case 0x7d:
                return exports.BlockHash;
            case 0x7e:
                return (0, exports.DEBUG)(bytestring_codec_1.byteStringsCodec._decode(input));
            case 0x7f:
                return exports.TxGasPrice;
            case 0x80:
                return exports.TxGasAmount;
            case 0x81:
                return exports.TxGasFee;
            case 0x82:
                return exports.I256Exp;
            case 0x83:
                return exports.U256Exp;
            case 0x84:
                return exports.U256ModExp;
            case 0x85:
                return exports.VerifyBIP340Schnorr;
            case 0x86:
                return exports.GetSegregatedSignature;
            case 0x87:
                return exports.MulModN;
            case 0x88:
                return exports.AddModN;
            case 0x89:
                return exports.U256ToString;
            case 0x8a:
                return exports.I256ToString;
            case 0x8b:
                return exports.BoolToString;
            case 0x8c:
                return exports.GroupOfAddress;
            case 0xa0:
                return (0, exports.LoadMutField)(codec_1.byteCodec._decode(input));
            case 0xa1:
                return (0, exports.StoreMutField)(codec_1.byteCodec._decode(input));
            case 0xa2:
                return exports.ApproveAlph;
            case 0xa3:
                return exports.ApproveToken;
            case 0xa4:
                return exports.AlphRemaining;
            case 0xa5:
                return exports.TokenRemaining;
            case 0xa6:
                return exports.IsPaying;
            case 0xa7:
                return exports.TransferAlph;
            case 0xa8:
                return exports.TransferAlphFromSelf;
            case 0xa9:
                return exports.TransferAlphToSelf;
            case 0xaa:
                return exports.TransferToken;
            case 0xab:
                return exports.TransferTokenFromSelf;
            case 0xac:
                return exports.TransferTokenToSelf;
            case 0xad:
                return exports.CreateContract;
            case 0xae:
                return exports.CreateContractWithToken;
            case 0xaf:
                return exports.CopyCreateContract;
            case 0xb0:
                return exports.DestroySelf;
            case 0xb1:
                return exports.SelfContractId;
            case 0xb2:
                return exports.SelfAddress;
            case 0xb3:
                return exports.CallerContractId;
            case 0xb4:
                return exports.CallerAddress;
            case 0xb5:
                return exports.IsCalledFromTxScript;
            case 0xb6:
                return exports.CallerInitialStateHash;
            case 0xb7:
                return exports.CallerCodeHash;
            case 0xb8:
                return exports.ContractInitialStateHash;
            case 0xb9:
                return exports.ContractCodeHash;
            case 0xba:
                return exports.MigrateSimple;
            case 0xbb:
                return exports.MigrateWithFields;
            case 0xbc:
                return exports.CopyCreateContractWithToken;
            case 0xbd:
                return exports.BurnToken;
            case 0xbe:
                return exports.LockApprovedAssets;
            case 0xbf:
                return exports.CreateSubContract;
            case 0xc0:
                return exports.CreateSubContractWithToken;
            case 0xc1:
                return exports.CopyCreateSubContract;
            case 0xc2:
                return exports.CopyCreateSubContractWithToken;
            case 0xc3:
                return exports.LoadMutFieldByIndex;
            case 0xc4:
                return exports.StoreMutFieldByIndex;
            case 0xc5:
                return exports.ContractExists;
            case 0xc6:
                return exports.CreateContractAndTransferToken;
            case 0xc7:
                return exports.CopyCreateContractAndTransferToken;
            case 0xc8:
                return exports.CreateSubContractAndTransferToken;
            case 0xc9:
                return exports.CopyCreateSubContractAndTransferToken;
            case 0xca:
                return exports.NullContractAddress;
            case 0xcb:
                return exports.SubContractId;
            case 0xcc:
                return exports.SubContractIdOf;
            case 0xcd:
                return exports.ALPHTokenId;
            case 0xce:
                return (0, exports.LoadImmField)(codec_1.byteCodec._decode(input));
            case 0xcf:
                return exports.LoadImmFieldByIndex;
            case 0xd0:
                return exports.PayGasFee;
            case 0xd1:
                return exports.MinimalContractDeposit;
            case 0xd2:
                return (0, exports.CreateMapEntry)(codec_1.byteCodec._decode(input), codec_1.byteCodec._decode(input));
            case 0xd3:
                return (0, exports.MethodSelector)(int_as_4bytes_codec_1.intAs4BytesCodec._decode(input));
            case 0xd4:
                return (0, exports.CallExternalBySelector)(int_as_4bytes_codec_1.intAs4BytesCodec._decode(input));
            default:
                throw new Error(`Unknown instr code: ${code}`);
        }
    }
}
exports.InstrCodec = InstrCodec;
exports.instrCodec = new InstrCodec();
exports.instrsCodec = new array_codec_1.ArrayCodec(exports.instrCodec);
function checkU256(number) {
    if (number < 0n || number >= 2n ** 256n) {
        throw new Error(`Invalid u256 number: ${number}`);
    }
}
function toU256(number) {
    checkU256(number);
    switch (number) {
        case 0n:
            return exports.U256Const0;
        case 1n:
            return exports.U256Const1;
        case 2n:
            return exports.U256Const2;
        case 3n:
            return exports.U256Const3;
        case 4n:
            return exports.U256Const4;
        case 5n:
            return exports.U256Const5;
        default:
            return (0, exports.U256Const)(number);
    }
}
exports.toU256 = toU256;
function checkI256(number) {
    const upperBound = 2n ** 255n;
    if (number < -upperBound || number >= upperBound) {
        throw new Error(`Invalid i256 number: ${number}`);
    }
}
function toI256(number) {
    checkI256(number);
    switch (number) {
        case 0n:
            return exports.I256Const0;
        case 1n:
            return exports.I256Const1;
        case 2n:
            return exports.I256Const2;
        case 3n:
            return exports.I256Const3;
        case 4n:
            return exports.I256Const4;
        case 5n:
            return exports.I256Const5;
        case -1n:
            return exports.I256ConstN1;
        default:
            return (0, exports.I256Const)(number);
    }
}
exports.toI256 = toI256;
