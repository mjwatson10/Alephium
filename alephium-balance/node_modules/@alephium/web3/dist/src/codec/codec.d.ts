import { Reader } from './reader';
export declare abstract class Codec<T> {
    abstract encode(input: T): Uint8Array;
    decode(input: Uint8Array): T;
    abstract _decode(input: Reader): T;
    bimap<R>(from: (v: T) => R, to: (v: R) => T): Codec<R>;
}
export declare function assert(value: boolean, message: string): void;
export declare class FixedSizeCodec extends Codec<Uint8Array> {
    private readonly size;
    constructor(size: number);
    encode(input: Uint8Array): Uint8Array;
    _decode(input: Reader): Uint8Array;
}
export declare class ObjectCodec<T> extends Codec<T> {
    private codecs;
    private keys;
    constructor(codecs: {
        [K in keyof T]: Codec<T[K]>;
    });
    encode(value: T): Uint8Array;
    _decode(input: Reader): T;
}
type ExtractKind<T> = T extends {
    kind: infer U extends string;
} ? U : never;
type ExtractValue<T, K> = T extends {
    kind: K;
    value: infer V;
} ? V : never;
export declare class EnumCodec<T extends {
    kind: ExtractKind<T>;
    value: ExtractValue<T, ExtractKind<T>>;
}> extends Codec<T> {
    private name;
    private codecs;
    private kinds;
    constructor(name: string, codecs: {
        [K in ExtractKind<T>]: Codec<ExtractValue<T, K>>;
    });
    encode(value: T): Uint8Array;
    _decode(input: Reader): T;
}
export declare const byte32Codec: FixedSizeCodec;
export declare const byteCodec: {
    encode(input: number): Uint8Array;
    _decode(input: Reader): number;
    decode(input: Uint8Array): number;
    bimap<R>(from: (v: number) => R, to: (v: R) => number): Codec<R>;
};
export declare const boolCodec: {
    encode(input: boolean): Uint8Array;
    _decode(input: Reader): boolean;
    decode(input: Uint8Array): boolean;
    bimap<R>(from: (v: boolean) => R, to: (v: R) => boolean): Codec<R>;
};
export {};
